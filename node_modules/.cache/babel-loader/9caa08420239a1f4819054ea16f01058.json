{"remainingRequest":"/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/babel-loader/lib/index.js!/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/feathers-vuex/dist/make-find-mixin.js","dependencies":[{"path":"/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/feathers-vuex/dist/make-find-mixin.js","mtime":1576553531990},{"path":"/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/cache-loader/dist/cjs.js","mtime":1576617922850},{"path":"/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/babel-loader/lib/index.js","mtime":1572970632149}],"contextDependencies":[],"result":["import \"core-js/modules/es6.string.starts-with\";\nimport \"core-js/modules/web.dom.iterable\";\nimport _defineProperty from \"/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport \"core-js/modules/es6.regexp.replace\";\nimport \"core-js/modules/es6.function.name\";\n\n/*\neslint\nno-console: 0,\n@typescript-eslint/explicit-function-return-type: 0,\n@typescript-eslint/no-explicit-any: 0\n*/\nimport { getServicePrefix, getServiceCapitalization, getQueryInfo, getItemsFromQueryInfo } from \"./utils\";\nimport debounce from 'lodash/debounce';\nimport _get from 'lodash/get';\nexport default function makeFindMixin(options) {\n  var _data, _computed, _methods;\n\n  var service = options.service,\n      params = options.params,\n      fetchQuery = options.fetchQuery,\n      _options$queryWhen = options.queryWhen,\n      queryWhen = _options$queryWhen === void 0 ? function () {\n    return true;\n  } : _options$queryWhen,\n      _options$local = options.local,\n      local = _options$local === void 0 ? false : _options$local,\n      _options$qid = options.qid,\n      qid = _options$qid === void 0 ? 'default' : _options$qid,\n      items = options.items,\n      debug = options.debug;\n  var name = options.name,\n      _options$watch = options.watch,\n      watch = _options$watch === void 0 ? [] : _options$watch;\n\n  if (typeof watch === 'string') {\n    watch = [watch];\n  } else if (typeof watch === 'boolean' && watch) {\n    watch = ['params'];\n  }\n\n  if (!service || typeof service !== 'string' && typeof service !== 'function') {\n    throw new Error(\"The 'service' option is required in the FeathersVuex make-find-mixin and must be a string.\");\n  }\n\n  if (typeof service === 'function' && !name) {\n    name = 'service';\n  }\n\n  var nameToUse = (name || service).replace('-', '_');\n  var prefix = getServicePrefix(nameToUse);\n  var capitalized = getServiceCapitalization(nameToUse);\n  var SERVICE_NAME = \"\".concat(prefix, \"ServiceName\");\n  var ITEMS = items || prefix;\n\n  if (typeof service === 'function' && name === 'service' && !items) {\n    ITEMS = 'items';\n  }\n\n  var ITEMS_FETCHED = \"\".concat(ITEMS, \"Fetched\");\n  var IS_FIND_PENDING = \"isFind\".concat(capitalized, \"Pending\");\n  var PARAMS = \"\".concat(prefix, \"Params\");\n  var FETCH_PARAMS = \"\".concat(prefix, \"FetchParams\");\n  var WATCH = \"\".concat(prefix, \"Watch\");\n  var QUERY_WHEN = \"\".concat(prefix, \"QueryWhen\");\n  var ERROR = \"\".concat(prefix, \"Error\");\n  var FIND_ACTION = \"find\".concat(capitalized);\n  var FIND_GETTER = \"find\".concat(capitalized, \"InStore\");\n  var HAVE_ITEMS_BEEN_REQUESTED_ONCE = \"have\".concat(capitalized, \"BeenRequestedOnce\");\n  var HAVE_ITEMS_LOADED_ONCE = \"have\".concat(capitalized, \"LoadedOnce\");\n  var PAGINATION = \"\".concat(prefix, \"PaginationData\");\n  var MOST_RECENT_QUERY = \"\".concat(prefix, \"LatestQuery\");\n  var LOCAL = \"\".concat(prefix, \"Local\");\n  var QID = \"\".concat(prefix, \"Qid\");\n\n  var _data2 = (_data = {}, _defineProperty(_data, IS_FIND_PENDING, false), _defineProperty(_data, HAVE_ITEMS_BEEN_REQUESTED_ONCE, false), _defineProperty(_data, HAVE_ITEMS_LOADED_ONCE, false), _defineProperty(_data, WATCH, watch), _defineProperty(_data, QID, qid), _defineProperty(_data, MOST_RECENT_QUERY, null), _defineProperty(_data, ERROR, null), _data); // Should only be used with actual fetching API calls.\n\n\n  var getParams = function getParams(_ref) {\n    var providedParams = _ref.providedParams,\n        params = _ref.params,\n        fetchParams = _ref.fetchParams;\n\n    if (providedParams) {\n      return providedParams;\n    } else {\n      // Returning null fetchParams allows the query to be skipped.\n      return fetchParams || fetchParams === null ? fetchParams : params;\n    }\n  };\n\n  var mixin = {\n    data: function data() {\n      return _data2;\n    },\n    computed: (_computed = {}, _defineProperty(_computed, PAGINATION, function () {\n      return this.$store.state[this[SERVICE_NAME]].pagination;\n    }), _defineProperty(_computed, ITEMS, function () {\n      var serviceName = this[SERVICE_NAME];\n      var serviceState = this.$store.state[serviceName]; // If both queries are provided, we're not using fall-through pagination.\n      // User can pass `paginate: false` to force old behavior with a single query.\n\n      if (this[FETCH_PARAMS] && this[PARAMS] || this[PARAMS] && this[PARAMS].paginate === false) {\n        return this.$store.getters[\"\".concat(serviceName, \"/find\")](this[PARAMS]).data;\n      }\n\n      var params = this[PARAMS]; // Check for pagination data for this query.\n\n      if (params) {\n        var _serviceState$paginat = serviceState.pagination,\n            defaultSkip = _serviceState$paginat.defaultSkip,\n            defaultLimit = _serviceState$paginat.defaultLimit;\n        var skip = params.query.$skip || defaultSkip;\n        var limit = params.query.$limit || defaultLimit;\n        var pagination = this[PAGINATION][params.qid || this[QID]] || {};\n        var response = skip != null && limit != null ? {\n          limit: limit,\n          skip: skip\n        } : {};\n        var queryInfo = getQueryInfo(params, response);\n\n        var _items = getItemsFromQueryInfo(pagination, queryInfo, serviceState.keyedById);\n\n        if (_items && _items.length) {\n          return _items;\n        }\n      }\n\n      return [];\n    }), _defineProperty(_computed, ITEMS_FETCHED, function () {\n      if (this[FETCH_PARAMS]) {\n        return this[FIND_GETTER](this[FETCH_PARAMS]).data;\n      } else {\n        return this[ITEMS];\n      }\n    }), _defineProperty(_computed, FIND_GETTER, function () {\n      var _this = this;\n\n      return function (params) {\n        var serviceName = _this[SERVICE_NAME];\n        return _this.$store.getters[\"\".concat(serviceName, \"/find\")](params);\n      };\n    }), _computed),\n    methods: (_methods = {}, _defineProperty(_methods, \"\".concat(FIND_ACTION, \"DebouncedProxy\"), function DebouncedProxy(params) {\n      var paramsToUse = getParams({\n        providedParams: params,\n        params: this[PARAMS],\n        fetchParams: this[FETCH_PARAMS]\n      });\n\n      if (paramsToUse && paramsToUse.debounce) {\n        var cachedDebounceFunction = this[\"\".concat(FIND_ACTION, \"Debounced\")];\n        var mostRecentTime = this[\"\".concat(FIND_ACTION, \"MostRecentDebounceTime\")];\n\n        if (!cachedDebounceFunction || mostRecentTime != paramsToUse.debounce) {\n          this[\"\".concat(FIND_ACTION, \"MostRecentDebounceTime\")] = paramsToUse.debounce;\n          this[\"\".concat(FIND_ACTION, \"Debounced\")] = debounce(this[FIND_ACTION], paramsToUse.debounce);\n        }\n\n        return this[\"\".concat(FIND_ACTION, \"Debounced\")](paramsToUse);\n      } else {\n        return this[FIND_ACTION](paramsToUse);\n      }\n    }), _defineProperty(_methods, FIND_ACTION, function (params) {\n      var _this2 = this;\n\n      var serviceName = this[SERVICE_NAME];\n      var paramsToUse = getParams({\n        providedParams: params,\n        params: this[PARAMS],\n        fetchParams: this[FETCH_PARAMS]\n      });\n\n      if (!this[LOCAL]) {\n        var shouldExecuteQuery = typeof this[QUERY_WHEN] === 'function' ? this[QUERY_WHEN](paramsToUse) : this[QUERY_WHEN];\n\n        if (shouldExecuteQuery) {\n          if (paramsToUse) {\n            // Set the qid.\n            paramsToUse.query = paramsToUse.query || {};\n            paramsToUse.qid = paramsToUse.qid || this[QID];\n            this[QID] = paramsToUse.qid;\n            this[IS_FIND_PENDING] = true;\n            this[HAVE_ITEMS_BEEN_REQUESTED_ONCE] = true;\n            return this.$store.dispatch(\"\".concat(serviceName, \"/find\"), paramsToUse).then(function (response) {\n              // To prevent thrashing, only clear ERROR on response, not on initial request.\n              _this2[ERROR] = null;\n              _this2[HAVE_ITEMS_LOADED_ONCE] = true;\n              var queryInfo = getQueryInfo(paramsToUse, response);\n              queryInfo.response = response;\n              queryInfo.isOutdated = false;\n              _this2[MOST_RECENT_QUERY] = queryInfo;\n              _this2[IS_FIND_PENDING] = false;\n              return response;\n            }).catch(function (error) {\n              _this2[ERROR] = error;\n              return error;\n            });\n          }\n        } else {\n          if (this[MOST_RECENT_QUERY]) {\n            this[MOST_RECENT_QUERY].isOutdated = true;\n          }\n        }\n      }\n    }), _defineProperty(_methods, \"getPaginationForQuery\", function getPaginationForQuery() {\n      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var pagination = this[PAGINATION];\n\n      var _getQueryInfo = getQueryInfo(params),\n          qid = _getQueryInfo.qid,\n          queryId = _getQueryInfo.queryId,\n          pageId = _getQueryInfo.pageId;\n\n      var queryInfo = _get(pagination, \"[\".concat(qid, \"][\").concat(queryId, \"]\")) || {};\n      var pageInfo = _get(pagination, \"[\".concat(qid, \"][\").concat(queryId, \"][\").concat(pageId, \"]\")) || {};\n      return {\n        queryInfo: queryInfo,\n        pageInfo: pageInfo\n      };\n    }), _methods),\n    created: function created() {\n      var _this3 = this;\n\n      debug && console.log(\"running 'created' hook in makeFindMixin for service \\\"\".concat(service, \"\\\" (using name \").concat(nameToUse, \"\\\")\"));\n      debug && console.log(PARAMS, this[PARAMS]);\n      debug && console.log(FETCH_PARAMS, this[FETCH_PARAMS]);\n      var pType = Object.getPrototypeOf(this);\n\n      if (pType.hasOwnProperty(PARAMS) || pType.hasOwnProperty(FETCH_PARAMS)) {\n        watch.forEach(function (prop) {\n          if (typeof prop !== 'string') {\n            throw new Error(\"Values in the 'watch' array must be strings.\");\n          }\n\n          prop = prop.replace('params', PARAMS);\n\n          if (pType.hasOwnProperty(FETCH_PARAMS)) {\n            if (prop.startsWith(PARAMS)) {\n              prop = prop.replace(PARAMS, FETCH_PARAMS);\n            }\n          }\n\n          _this3.$watch(prop, function () {\n            // If the request is going to be debounced, set IS_FIND_PENDING to true.\n            // Without this, there's not a way to show a loading indicator during the debounce timeout.\n            var paramsToUse = getParams({\n              providedParams: null,\n              params: this[PARAMS],\n              fetchParams: this[FETCH_PARAMS]\n            });\n\n            if (paramsToUse && paramsToUse.debounce) {\n              this[IS_FIND_PENDING] = true;\n            }\n\n            return this[\"\".concat(FIND_ACTION, \"DebouncedProxy\")]();\n          });\n        });\n        return this[FIND_ACTION]();\n      } else {\n        if (!local) {\n          // TODO: Add this message to the logging:\n          //       \"Pass { local: true } to disable this warning and only do local queries.\"\n          console.log(\"No \\\"\".concat(PARAMS, \"\\\" or \\\"\").concat(FETCH_PARAMS, \"\\\" attribute was found in the makeFindMixin for the \\\"\").concat(service, \"\\\" service (using name \\\"\").concat(nameToUse, \"\\\").  No queries will be made.\"));\n        }\n      }\n    }\n  };\n\n  function hasSomeAttribute(vm) {\n    for (var _len = arguments.length, attributes = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      attributes[_key - 1] = arguments[_key];\n    }\n\n    return attributes.some(function (a) {\n      return vm.hasOwnProperty(a) || Object.getPrototypeOf(vm).hasOwnProperty(a);\n    });\n  }\n\n  function setupAttribute(NAME, value) {\n    var computedOrMethods = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'computed';\n    var returnTheValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n    if (typeof value === 'boolean') {\n      _data2[NAME] = !!value;\n    } else if (typeof value === 'string') {\n      mixin.computed[NAME] = function () {\n        // If the specified computed prop wasn't found, display an error.\n        if (!returnTheValue) {\n          if (!hasSomeAttribute(this, value, NAME)) {\n            throw new Error(\"Value for \".concat(NAME, \" was not found on the component at '\").concat(value, \"'.\"));\n          }\n        }\n\n        return returnTheValue ? value : this[value];\n      };\n    } else if (typeof value === 'function') {\n      mixin[computedOrMethods][NAME] = value;\n    }\n  }\n\n  setupAttribute(SERVICE_NAME, service, 'computed', true);\n  setupAttribute(PARAMS, params);\n  setupAttribute(FETCH_PARAMS, fetchQuery);\n  setupAttribute(QUERY_WHEN, queryWhen, 'computed');\n  setupAttribute(LOCAL, local);\n  return mixin;\n}",{"version":3,"sources":["/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/feathers-vuex/dist/make-find-mixin.js"],"names":["getServicePrefix","getServiceCapitalization","getQueryInfo","getItemsFromQueryInfo","debounce","_get","makeFindMixin","options","service","params","fetchQuery","queryWhen","local","qid","items","debug","name","watch","Error","nameToUse","replace","prefix","capitalized","SERVICE_NAME","ITEMS","ITEMS_FETCHED","IS_FIND_PENDING","PARAMS","FETCH_PARAMS","WATCH","QUERY_WHEN","ERROR","FIND_ACTION","FIND_GETTER","HAVE_ITEMS_BEEN_REQUESTED_ONCE","HAVE_ITEMS_LOADED_ONCE","PAGINATION","MOST_RECENT_QUERY","LOCAL","QID","data","getParams","providedParams","fetchParams","mixin","computed","$store","state","pagination","serviceName","serviceState","paginate","getters","defaultSkip","defaultLimit","skip","query","$skip","limit","$limit","response","queryInfo","keyedById","length","methods","paramsToUse","cachedDebounceFunction","mostRecentTime","shouldExecuteQuery","dispatch","then","isOutdated","catch","error","queryId","pageId","pageInfo","created","console","log","pType","Object","getPrototypeOf","hasOwnProperty","forEach","prop","startsWith","$watch","hasSomeAttribute","vm","attributes","some","a","setupAttribute","NAME","value","computedOrMethods","returnTheValue"],"mappings":";;;;;;AAAA;;;;;;AAMA,SACEA,gBADF,EAEEC,wBAFF,EAGEC,YAHF,EAIEC,qBAJF;AAMA,OAAOC,QAAP,MAAqB,iBAArB;AACA,OAAOC,IAAP,MAAiB,YAAjB;AACA,eAAe,SAASC,aAAT,CAAuBC,OAAvB,EAAgC;AAAA;;AAAA,MAE3CC,OAF2C,GAUzCD,OAVyC,CAE3CC,OAF2C;AAAA,MAG3CC,MAH2C,GAUzCF,OAVyC,CAG3CE,MAH2C;AAAA,MAI3CC,UAJ2C,GAUzCH,OAVyC,CAI3CG,UAJ2C;AAAA,2BAUzCH,OAVyC,CAK3CI,SAL2C;AAAA,MAK3CA,SAL2C,mCAK/B;AAAA,WAAM,IAAN;AAAA,GAL+B;AAAA,uBAUzCJ,OAVyC,CAM3CK,KAN2C;AAAA,MAM3CA,KAN2C,+BAMnC,KANmC;AAAA,qBAUzCL,OAVyC,CAO3CM,GAP2C;AAAA,MAO3CA,GAP2C,6BAOrC,SAPqC;AAAA,MAQ3CC,KAR2C,GAUzCP,OAVyC,CAQ3CO,KAR2C;AAAA,MAS3CC,KAT2C,GAUzCR,OAVyC,CAS3CQ,KAT2C;AAAA,MAWvCC,IAXuC,GAWlBT,OAXkB,CAWvCS,IAXuC;AAAA,uBAWlBT,OAXkB,CAWjCU,KAXiC;AAAA,MAWjCA,KAXiC,+BAWzB,EAXyB;;AAY7C,MAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC7BA,IAAAA,KAAK,GAAG,CAACA,KAAD,CAAR;AACD,GAFD,MAEO,IAAI,OAAOA,KAAP,KAAiB,SAAjB,IAA8BA,KAAlC,EAAyC;AAC9CA,IAAAA,KAAK,GAAG,CAAC,QAAD,CAAR;AACD;;AACD,MACE,CAACT,OAAD,IACC,OAAOA,OAAP,KAAmB,QAAnB,IAA+B,OAAOA,OAAP,KAAmB,UAFrD,EAGE;AACA,UAAM,IAAIU,KAAJ,8FAAN;AAGD;;AACD,MAAI,OAAOV,OAAP,KAAmB,UAAnB,IAAiC,CAACQ,IAAtC,EAA4C;AAC1CA,IAAAA,IAAI,GAAG,SAAP;AACD;;AACD,MAAMG,SAAS,GAAG,CAACH,IAAI,IAAIR,OAAT,EAAkBY,OAAlB,CAA0B,GAA1B,EAA+B,GAA/B,CAAlB;AACA,MAAMC,MAAM,GAAGrB,gBAAgB,CAACmB,SAAD,CAA/B;AACA,MAAMG,WAAW,GAAGrB,wBAAwB,CAACkB,SAAD,CAA5C;AACA,MAAMI,YAAY,aAAMF,MAAN,gBAAlB;AACA,MAAIG,KAAK,GAAGV,KAAK,IAAIO,MAArB;;AACA,MAAI,OAAOb,OAAP,KAAmB,UAAnB,IAAiCQ,IAAI,KAAK,SAA1C,IAAuD,CAACF,KAA5D,EAAmE;AACjEU,IAAAA,KAAK,GAAG,OAAR;AACD;;AACD,MAAMC,aAAa,aAAMD,KAAN,YAAnB;AACA,MAAME,eAAe,mBAAYJ,WAAZ,YAArB;AACA,MAAMK,MAAM,aAAMN,MAAN,WAAZ;AACA,MAAMO,YAAY,aAAMP,MAAN,gBAAlB;AACA,MAAMQ,KAAK,aAAMR,MAAN,UAAX;AACA,MAAMS,UAAU,aAAMT,MAAN,cAAhB;AACA,MAAMU,KAAK,aAAMV,MAAN,UAAX;AACA,MAAMW,WAAW,iBAAUV,WAAV,CAAjB;AACA,MAAMW,WAAW,iBAAUX,WAAV,YAAjB;AACA,MAAMY,8BAA8B,iBAAUZ,WAAV,sBAApC;AACA,MAAMa,sBAAsB,iBAAUb,WAAV,eAA5B;AACA,MAAMc,UAAU,aAAMf,MAAN,mBAAhB;AACA,MAAMgB,iBAAiB,aAAMhB,MAAN,gBAAvB;AACA,MAAMiB,KAAK,aAAMjB,MAAN,UAAX;AACA,MAAMkB,GAAG,aAAMlB,MAAN,QAAT;;AACA,MAAMmB,MAAI,uCACPd,eADO,EACW,KADX,0BAEPQ,8BAFO,EAE0B,KAF1B,0BAGPC,sBAHO,EAGkB,KAHlB,0BAIPN,KAJO,EAICZ,KAJD,0BAKPsB,GALO,EAKD1B,GALC,0BAMPwB,iBANO,EAMa,IANb,0BAOPN,KAPO,EAOC,IAPD,SAAV,CAnD6C,CA4D7C;;;AACA,MAAMU,SAAS,GAAG,SAAZA,SAAY,OAA6C;AAAA,QAA1CC,cAA0C,QAA1CA,cAA0C;AAAA,QAA1BjC,MAA0B,QAA1BA,MAA0B;AAAA,QAAlBkC,WAAkB,QAAlBA,WAAkB;;AAC7D,QAAID,cAAJ,EAAoB;AAClB,aAAOA,cAAP;AACD,KAFD,MAEO;AACL;AACA,aAAOC,WAAW,IAAIA,WAAW,KAAK,IAA/B,GAAsCA,WAAtC,GAAoDlC,MAA3D;AACD;AACF,GAPD;;AAQA,MAAMmC,KAAK,GAAG;AACZJ,IAAAA,IADY,kBACL;AACL,aAAOA,MAAP;AACD,KAHW;AAIZK,IAAAA,QAAQ,8CACLT,UADK,cACS;AACb,aAAO,KAAKU,MAAL,CAAYC,KAAZ,CAAkB,KAAKxB,YAAL,CAAlB,EAAsCyB,UAA7C;AACD,KAHK,8BAILxB,KAJK,cAII;AACR,UAAMyB,WAAW,GAAG,KAAK1B,YAAL,CAApB;AACA,UAAM2B,YAAY,GAAG,KAAKJ,MAAL,CAAYC,KAAZ,CAAkBE,WAAlB,CAArB,CAFQ,CAGR;AACA;;AACA,UACG,KAAKrB,YAAL,KAAsB,KAAKD,MAAL,CAAvB,IACC,KAAKA,MAAL,KAAgB,KAAKA,MAAL,EAAawB,QAAb,KAA0B,KAF7C,EAGE;AACA,eAAO,KAAKL,MAAL,CAAYM,OAAZ,WAAuBH,WAAvB,YAA2C,KAAKtB,MAAL,CAA3C,EAAyDa,IAAhE;AACD;;AACD,UAAM/B,MAAM,GAAG,KAAKkB,MAAL,CAAf,CAXQ,CAYR;;AACA,UAAIlB,MAAJ,EAAY;AAAA,oCAC4ByC,YAAY,CAACF,UADzC;AAAA,YACFK,WADE,yBACFA,WADE;AAAA,YACWC,YADX,yBACWA,YADX;AAEV,YAAMC,IAAI,GAAG9C,MAAM,CAAC+C,KAAP,CAAaC,KAAb,IAAsBJ,WAAnC;AACA,YAAMK,KAAK,GAAGjD,MAAM,CAAC+C,KAAP,CAAaG,MAAb,IAAuBL,YAArC;AACA,YAAMN,UAAU,GAAG,KAAKZ,UAAL,EAAiB3B,MAAM,CAACI,GAAP,IAAc,KAAK0B,GAAL,CAA/B,KAA6C,EAAhE;AACA,YAAMqB,QAAQ,GAAGL,IAAI,IAAI,IAAR,IAAgBG,KAAK,IAAI,IAAzB,GAAgC;AAAEA,UAAAA,KAAK,EAALA,KAAF;AAASH,UAAAA,IAAI,EAAJA;AAAT,SAAhC,GAAkD,EAAnE;AACA,YAAMM,SAAS,GAAG3D,YAAY,CAACO,MAAD,EAASmD,QAAT,CAA9B;;AACA,YAAM9C,MAAK,GAAGX,qBAAqB,CACjC6C,UADiC,EAEjCa,SAFiC,EAGjCX,YAAY,CAACY,SAHoB,CAAnC;;AAKA,YAAIhD,MAAK,IAAIA,MAAK,CAACiD,MAAnB,EAA2B;AACzB,iBAAOjD,MAAP;AACD;AACF;;AACD,aAAO,EAAP;AACD,KAlCK,8BAoCLW,aApCK,cAoCY;AAChB,UAAI,KAAKG,YAAL,CAAJ,EAAwB;AACtB,eAAO,KAAKK,WAAL,EAAkB,KAAKL,YAAL,CAAlB,EAAsCY,IAA7C;AACD,OAFD,MAEO;AACL,eAAO,KAAKhB,KAAL,CAAP;AACD;AACF,KA1CK,8BA4CLS,WA5CK,cA4CU;AAAA;;AACd,aAAO,UAAAxB,MAAM,EAAI;AACf,YAAMwC,WAAW,GAAG,KAAI,CAAC1B,YAAD,CAAxB;AACA,eAAO,KAAI,CAACuB,MAAL,CAAYM,OAAZ,WAAuBH,WAAvB,YAA2CxC,MAA3C,CAAP;AACD,OAHD;AAID,KAjDK,aAJI;AAuDZuD,IAAAA,OAAO,sDACDhC,WADC,6CAC4BvB,MAD5B,EACoC;AACvC,UAAMwD,WAAW,GAAGxB,SAAS,CAAC;AAC5BC,QAAAA,cAAc,EAAEjC,MADY;AAE5BA,QAAAA,MAAM,EAAE,KAAKkB,MAAL,CAFoB;AAG5BgB,QAAAA,WAAW,EAAE,KAAKf,YAAL;AAHe,OAAD,CAA7B;;AAKA,UAAIqC,WAAW,IAAIA,WAAW,CAAC7D,QAA/B,EAAyC;AACvC,YAAM8D,sBAAsB,GAAG,eAAQlC,WAAR,eAA/B;AACA,YAAMmC,cAAc,GAAG,eAAQnC,WAAR,4BAAvB;;AACA,YACE,CAACkC,sBAAD,IACAC,cAAc,IAAIF,WAAW,CAAC7D,QAFhC,EAGE;AACA,yBAAQ4B,WAAR,+BAA+CiC,WAAW,CAAC7D,QAA3D;AACA,yBAAQ4B,WAAR,kBAAkC5B,QAAQ,CACxC,KAAK4B,WAAL,CADwC,EAExCiC,WAAW,CAAC7D,QAF4B,CAA1C;AAID;;AACD,eAAO,eAAQ4B,WAAR,gBAAgCiC,WAAhC,CAAP;AACD,OAdD,MAcO;AACL,eAAO,KAAKjC,WAAL,EAAkBiC,WAAlB,CAAP;AACD;AACF,KAxBI,6BAyBJjC,WAzBI,YAyBSvB,MAzBT,EAyBiB;AAAA;;AACpB,UAAMwC,WAAW,GAAG,KAAK1B,YAAL,CAApB;AACA,UAAM0C,WAAW,GAAGxB,SAAS,CAAC;AAC5BC,QAAAA,cAAc,EAAEjC,MADY;AAE5BA,QAAAA,MAAM,EAAE,KAAKkB,MAAL,CAFoB;AAG5BgB,QAAAA,WAAW,EAAE,KAAKf,YAAL;AAHe,OAAD,CAA7B;;AAKA,UAAI,CAAC,KAAKU,KAAL,CAAL,EAAkB;AAChB,YAAM8B,kBAAkB,GACtB,OAAO,KAAKtC,UAAL,CAAP,KAA4B,UAA5B,GACI,KAAKA,UAAL,EAAiBmC,WAAjB,CADJ,GAEI,KAAKnC,UAAL,CAHN;;AAIA,YAAIsC,kBAAJ,EAAwB;AACtB,cAAIH,WAAJ,EAAiB;AACf;AACAA,YAAAA,WAAW,CAACT,KAAZ,GAAoBS,WAAW,CAACT,KAAZ,IAAqB,EAAzC;AACAS,YAAAA,WAAW,CAACpD,GAAZ,GAAkBoD,WAAW,CAACpD,GAAZ,IAAmB,KAAK0B,GAAL,CAArC;AACA,iBAAKA,GAAL,IAAY0B,WAAW,CAACpD,GAAxB;AACA,iBAAKa,eAAL,IAAwB,IAAxB;AACA,iBAAKQ,8BAAL,IAAuC,IAAvC;AACA,mBAAO,KAAKY,MAAL,CACJuB,QADI,WACQpB,WADR,YAC4BgB,WAD5B,EAEJK,IAFI,CAEC,UAAAV,QAAQ,EAAI;AAChB;AACA,cAAA,MAAI,CAAC7B,KAAD,CAAJ,GAAc,IAAd;AACA,cAAA,MAAI,CAACI,sBAAD,CAAJ,GAA+B,IAA/B;AACA,kBAAM0B,SAAS,GAAG3D,YAAY,CAAC+D,WAAD,EAAcL,QAAd,CAA9B;AACAC,cAAAA,SAAS,CAACD,QAAV,GAAqBA,QAArB;AACAC,cAAAA,SAAS,CAACU,UAAV,GAAuB,KAAvB;AACA,cAAA,MAAI,CAAClC,iBAAD,CAAJ,GAA0BwB,SAA1B;AACA,cAAA,MAAI,CAACnC,eAAD,CAAJ,GAAwB,KAAxB;AACA,qBAAOkC,QAAP;AACD,aAZI,EAaJY,KAbI,CAaE,UAAAC,KAAK,EAAI;AACd,cAAA,MAAI,CAAC1C,KAAD,CAAJ,GAAc0C,KAAd;AACA,qBAAOA,KAAP;AACD,aAhBI,CAAP;AAiBD;AACF,SA1BD,MA0BO;AACL,cAAI,KAAKpC,iBAAL,CAAJ,EAA6B;AAC3B,iBAAKA,iBAAL,EAAwBkC,UAAxB,GAAqC,IAArC;AACD;AACF;AACF;AACF,KArEI,uFAsE8B;AAAA,UAAb9D,MAAa,uEAAJ,EAAI;AACjC,UAAMuC,UAAU,GAAG,KAAKZ,UAAL,CAAnB;;AADiC,0BAEAlC,YAAY,CAACO,MAAD,CAFZ;AAAA,UAEzBI,GAFyB,iBAEzBA,GAFyB;AAAA,UAEpB6D,OAFoB,iBAEpBA,OAFoB;AAAA,UAEXC,MAFW,iBAEXA,MAFW;;AAGjC,UAAMd,SAAS,GAAGxD,IAAI,CAAC2C,UAAD,aAAiBnC,GAAjB,eAAyB6D,OAAzB,OAAJ,IAA4C,EAA9D;AACA,UAAME,QAAQ,GACZvE,IAAI,CAAC2C,UAAD,aAAiBnC,GAAjB,eAAyB6D,OAAzB,eAAqCC,MAArC,OAAJ,IAAuD,EADzD;AAEA,aAAO;AAAEd,QAAAA,SAAS,EAATA,SAAF;AAAae,QAAAA,QAAQ,EAARA;AAAb,OAAP;AACD,KA7EI,YAvDK;AAsIZC,IAAAA,OAtIY,qBAsIF;AAAA;;AACR9D,MAAAA,KAAK,IACH+D,OAAO,CAACC,GAAR,iEAC0DvE,OAD1D,4BACkFW,SADlF,SADF;AAIAJ,MAAAA,KAAK,IAAI+D,OAAO,CAACC,GAAR,CAAYpD,MAAZ,EAAoB,KAAKA,MAAL,CAApB,CAAT;AACAZ,MAAAA,KAAK,IAAI+D,OAAO,CAACC,GAAR,CAAYnD,YAAZ,EAA0B,KAAKA,YAAL,CAA1B,CAAT;AACA,UAAMoD,KAAK,GAAGC,MAAM,CAACC,cAAP,CAAsB,IAAtB,CAAd;;AACA,UAAIF,KAAK,CAACG,cAAN,CAAqBxD,MAArB,KAAgCqD,KAAK,CAACG,cAAN,CAAqBvD,YAArB,CAApC,EAAwE;AACtEX,QAAAA,KAAK,CAACmE,OAAN,CAAc,UAAAC,IAAI,EAAI;AACpB,cAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;AAC5B,kBAAM,IAAInE,KAAJ,gDAAN;AACD;;AACDmE,UAAAA,IAAI,GAAGA,IAAI,CAACjE,OAAL,CAAa,QAAb,EAAuBO,MAAvB,CAAP;;AACA,cAAIqD,KAAK,CAACG,cAAN,CAAqBvD,YAArB,CAAJ,EAAwC;AACtC,gBAAIyD,IAAI,CAACC,UAAL,CAAgB3D,MAAhB,CAAJ,EAA6B;AAC3B0D,cAAAA,IAAI,GAAGA,IAAI,CAACjE,OAAL,CAAaO,MAAb,EAAqBC,YAArB,CAAP;AACD;AACF;;AACD,UAAA,MAAI,CAAC2D,MAAL,CAAYF,IAAZ,EAAkB,YAAW;AAC3B;AACA;AACA,gBAAMpB,WAAW,GAAGxB,SAAS,CAAC;AAC5BC,cAAAA,cAAc,EAAE,IADY;AAE5BjC,cAAAA,MAAM,EAAE,KAAKkB,MAAL,CAFoB;AAG5BgB,cAAAA,WAAW,EAAE,KAAKf,YAAL;AAHe,aAAD,CAA7B;;AAKA,gBAAIqC,WAAW,IAAIA,WAAW,CAAC7D,QAA/B,EAAyC;AACvC,mBAAKsB,eAAL,IAAwB,IAAxB;AACD;;AACD,mBAAO,eAAQM,WAAR,sBAAP;AACD,WAZD;AAaD,SAvBD;AAwBA,eAAO,KAAKA,WAAL,GAAP;AACD,OA1BD,MA0BO;AACL,YAAI,CAACpB,KAAL,EAAY;AACV;AACA;AACAkE,UAAAA,OAAO,CAACC,GAAR,gBACSpD,MADT,qBACwBC,YADxB,mEAC2FpB,OAD3F,sCAC4HW,SAD5H;AAGD;AACF;AACF;AAjLW,GAAd;;AAmLA,WAASqE,gBAAT,CAA0BC,EAA1B,EAA6C;AAAA,sCAAZC,UAAY;AAAZA,MAAAA,UAAY;AAAA;;AAC3C,WAAOA,UAAU,CAACC,IAAX,CAAgB,UAAAC,CAAC,EAAI;AAC1B,aAAOH,EAAE,CAACN,cAAH,CAAkBS,CAAlB,KAAwBX,MAAM,CAACC,cAAP,CAAsBO,EAAtB,EAA0BN,cAA1B,CAAyCS,CAAzC,CAA/B;AACD,KAFM,CAAP;AAGD;;AACD,WAASC,cAAT,CACEC,IADF,EAEEC,KAFF,EAKE;AAAA,QAFAC,iBAEA,uEAFoB,UAEpB;AAAA,QADAC,cACA,uEADiB,KACjB;;AACA,QAAI,OAAOF,KAAP,KAAiB,SAArB,EAAgC;AAC9BvD,MAAAA,MAAI,CAACsD,IAAD,CAAJ,GAAa,CAAC,CAACC,KAAf;AACD,KAFD,MAEO,IAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AACpCnD,MAAAA,KAAK,CAACC,QAAN,CAAeiD,IAAf,IAAuB,YAAW;AAChC;AACA,YAAI,CAACG,cAAL,EAAqB;AACnB,cAAI,CAACT,gBAAgB,CAAC,IAAD,EAAOO,KAAP,EAAcD,IAAd,CAArB,EAA0C;AACxC,kBAAM,IAAI5E,KAAJ,qBACS4E,IADT,iDACoDC,KADpD,QAAN;AAGD;AACF;;AACD,eAAOE,cAAc,GAAGF,KAAH,GAAW,KAAKA,KAAL,CAAhC;AACD,OAVD;AAWD,KAZM,MAYA,IAAI,OAAOA,KAAP,KAAiB,UAArB,EAAiC;AACtCnD,MAAAA,KAAK,CAACoD,iBAAD,CAAL,CAAyBF,IAAzB,IAAiCC,KAAjC;AACD;AACF;;AACDF,EAAAA,cAAc,CAACtE,YAAD,EAAef,OAAf,EAAwB,UAAxB,EAAoC,IAApC,CAAd;AACAqF,EAAAA,cAAc,CAAClE,MAAD,EAASlB,MAAT,CAAd;AACAoF,EAAAA,cAAc,CAACjE,YAAD,EAAelB,UAAf,CAAd;AACAmF,EAAAA,cAAc,CAAC/D,UAAD,EAAanB,SAAb,EAAwB,UAAxB,CAAd;AACAkF,EAAAA,cAAc,CAACvD,KAAD,EAAQ1B,KAAR,CAAd;AACA,SAAOgC,KAAP;AACD","sourcesContent":["/*\neslint\nno-console: 0,\n@typescript-eslint/explicit-function-return-type: 0,\n@typescript-eslint/no-explicit-any: 0\n*/\nimport {\n  getServicePrefix,\n  getServiceCapitalization,\n  getQueryInfo,\n  getItemsFromQueryInfo\n} from './utils'\nimport debounce from 'lodash/debounce'\nimport _get from 'lodash/get'\nexport default function makeFindMixin(options) {\n  const {\n    service,\n    params,\n    fetchQuery,\n    queryWhen = () => true,\n    local = false,\n    qid = 'default',\n    items,\n    debug\n  } = options\n  let { name, watch = [] } = options\n  if (typeof watch === 'string') {\n    watch = [watch]\n  } else if (typeof watch === 'boolean' && watch) {\n    watch = ['params']\n  }\n  if (\n    !service ||\n    (typeof service !== 'string' && typeof service !== 'function')\n  ) {\n    throw new Error(\n      `The 'service' option is required in the FeathersVuex make-find-mixin and must be a string.`\n    )\n  }\n  if (typeof service === 'function' && !name) {\n    name = 'service'\n  }\n  const nameToUse = (name || service).replace('-', '_')\n  const prefix = getServicePrefix(nameToUse)\n  const capitalized = getServiceCapitalization(nameToUse)\n  const SERVICE_NAME = `${prefix}ServiceName`\n  let ITEMS = items || prefix\n  if (typeof service === 'function' && name === 'service' && !items) {\n    ITEMS = 'items'\n  }\n  const ITEMS_FETCHED = `${ITEMS}Fetched`\n  const IS_FIND_PENDING = `isFind${capitalized}Pending`\n  const PARAMS = `${prefix}Params`\n  const FETCH_PARAMS = `${prefix}FetchParams`\n  const WATCH = `${prefix}Watch`\n  const QUERY_WHEN = `${prefix}QueryWhen`\n  const ERROR = `${prefix}Error`\n  const FIND_ACTION = `find${capitalized}`\n  const FIND_GETTER = `find${capitalized}InStore`\n  const HAVE_ITEMS_BEEN_REQUESTED_ONCE = `have${capitalized}BeenRequestedOnce`\n  const HAVE_ITEMS_LOADED_ONCE = `have${capitalized}LoadedOnce`\n  const PAGINATION = `${prefix}PaginationData`\n  const MOST_RECENT_QUERY = `${prefix}LatestQuery`\n  const LOCAL = `${prefix}Local`\n  const QID = `${prefix}Qid`\n  const data = {\n    [IS_FIND_PENDING]: false,\n    [HAVE_ITEMS_BEEN_REQUESTED_ONCE]: false,\n    [HAVE_ITEMS_LOADED_ONCE]: false,\n    [WATCH]: watch,\n    [QID]: qid,\n    [MOST_RECENT_QUERY]: null,\n    [ERROR]: null\n  }\n  // Should only be used with actual fetching API calls.\n  const getParams = ({ providedParams, params, fetchParams }) => {\n    if (providedParams) {\n      return providedParams\n    } else {\n      // Returning null fetchParams allows the query to be skipped.\n      return fetchParams || fetchParams === null ? fetchParams : params\n    }\n  }\n  const mixin = {\n    data() {\n      return data\n    },\n    computed: {\n      [PAGINATION]() {\n        return this.$store.state[this[SERVICE_NAME]].pagination\n      },\n      [ITEMS]() {\n        const serviceName = this[SERVICE_NAME]\n        const serviceState = this.$store.state[serviceName]\n        // If both queries are provided, we're not using fall-through pagination.\n        // User can pass `paginate: false` to force old behavior with a single query.\n        if (\n          (this[FETCH_PARAMS] && this[PARAMS]) ||\n          (this[PARAMS] && this[PARAMS].paginate === false)\n        ) {\n          return this.$store.getters[`${serviceName}/find`](this[PARAMS]).data\n        }\n        const params = this[PARAMS]\n        // Check for pagination data for this query.\n        if (params) {\n          const { defaultSkip, defaultLimit } = serviceState.pagination\n          const skip = params.query.$skip || defaultSkip\n          const limit = params.query.$limit || defaultLimit\n          const pagination = this[PAGINATION][params.qid || this[QID]] || {}\n          const response = skip != null && limit != null ? { limit, skip } : {}\n          const queryInfo = getQueryInfo(params, response)\n          const items = getItemsFromQueryInfo(\n            pagination,\n            queryInfo,\n            serviceState.keyedById\n          )\n          if (items && items.length) {\n            return items\n          }\n        }\n        return []\n      },\n      // Queries the Vuex store with the exact same query that was sent to the API server.\n      [ITEMS_FETCHED]() {\n        if (this[FETCH_PARAMS]) {\n          return this[FIND_GETTER](this[FETCH_PARAMS]).data\n        } else {\n          return this[ITEMS]\n        }\n      },\n      // Exposes `findItemsInStore\n      [FIND_GETTER]() {\n        return params => {\n          const serviceName = this[SERVICE_NAME]\n          return this.$store.getters[`${serviceName}/find`](params)\n        }\n      }\n    },\n    methods: {\n      [`${FIND_ACTION}DebouncedProxy`](params) {\n        const paramsToUse = getParams({\n          providedParams: params,\n          params: this[PARAMS],\n          fetchParams: this[FETCH_PARAMS]\n        })\n        if (paramsToUse && paramsToUse.debounce) {\n          const cachedDebounceFunction = this[`${FIND_ACTION}Debounced`]\n          const mostRecentTime = this[`${FIND_ACTION}MostRecentDebounceTime`]\n          if (\n            !cachedDebounceFunction ||\n            mostRecentTime != paramsToUse.debounce\n          ) {\n            this[`${FIND_ACTION}MostRecentDebounceTime`] = paramsToUse.debounce\n            this[`${FIND_ACTION}Debounced`] = debounce(\n              this[FIND_ACTION],\n              paramsToUse.debounce\n            )\n          }\n          return this[`${FIND_ACTION}Debounced`](paramsToUse)\n        } else {\n          return this[FIND_ACTION](paramsToUse)\n        }\n      },\n      [FIND_ACTION](params) {\n        const serviceName = this[SERVICE_NAME]\n        const paramsToUse = getParams({\n          providedParams: params,\n          params: this[PARAMS],\n          fetchParams: this[FETCH_PARAMS]\n        })\n        if (!this[LOCAL]) {\n          const shouldExecuteQuery =\n            typeof this[QUERY_WHEN] === 'function'\n              ? this[QUERY_WHEN](paramsToUse)\n              : this[QUERY_WHEN]\n          if (shouldExecuteQuery) {\n            if (paramsToUse) {\n              // Set the qid.\n              paramsToUse.query = paramsToUse.query || {}\n              paramsToUse.qid = paramsToUse.qid || this[QID]\n              this[QID] = paramsToUse.qid\n              this[IS_FIND_PENDING] = true\n              this[HAVE_ITEMS_BEEN_REQUESTED_ONCE] = true\n              return this.$store\n                .dispatch(`${serviceName}/find`, paramsToUse)\n                .then(response => {\n                  // To prevent thrashing, only clear ERROR on response, not on initial request.\n                  this[ERROR] = null\n                  this[HAVE_ITEMS_LOADED_ONCE] = true\n                  const queryInfo = getQueryInfo(paramsToUse, response)\n                  queryInfo.response = response\n                  queryInfo.isOutdated = false\n                  this[MOST_RECENT_QUERY] = queryInfo\n                  this[IS_FIND_PENDING] = false\n                  return response\n                })\n                .catch(error => {\n                  this[ERROR] = error\n                  return error\n                })\n            }\n          } else {\n            if (this[MOST_RECENT_QUERY]) {\n              this[MOST_RECENT_QUERY].isOutdated = true\n            }\n          }\n        }\n      },\n      getPaginationForQuery(params = {}) {\n        const pagination = this[PAGINATION]\n        const { qid, queryId, pageId } = getQueryInfo(params)\n        const queryInfo = _get(pagination, `[${qid}][${queryId}]`) || {}\n        const pageInfo =\n          _get(pagination, `[${qid}][${queryId}][${pageId}]`) || {}\n        return { queryInfo, pageInfo }\n      }\n    },\n    created() {\n      debug &&\n        console.log(\n          `running 'created' hook in makeFindMixin for service \"${service}\" (using name ${nameToUse}\")`\n        )\n      debug && console.log(PARAMS, this[PARAMS])\n      debug && console.log(FETCH_PARAMS, this[FETCH_PARAMS])\n      const pType = Object.getPrototypeOf(this)\n      if (pType.hasOwnProperty(PARAMS) || pType.hasOwnProperty(FETCH_PARAMS)) {\n        watch.forEach(prop => {\n          if (typeof prop !== 'string') {\n            throw new Error(`Values in the 'watch' array must be strings.`)\n          }\n          prop = prop.replace('params', PARAMS)\n          if (pType.hasOwnProperty(FETCH_PARAMS)) {\n            if (prop.startsWith(PARAMS)) {\n              prop = prop.replace(PARAMS, FETCH_PARAMS)\n            }\n          }\n          this.$watch(prop, function() {\n            // If the request is going to be debounced, set IS_FIND_PENDING to true.\n            // Without this, there's not a way to show a loading indicator during the debounce timeout.\n            const paramsToUse = getParams({\n              providedParams: null,\n              params: this[PARAMS],\n              fetchParams: this[FETCH_PARAMS]\n            })\n            if (paramsToUse && paramsToUse.debounce) {\n              this[IS_FIND_PENDING] = true\n            }\n            return this[`${FIND_ACTION}DebouncedProxy`]()\n          })\n        })\n        return this[FIND_ACTION]()\n      } else {\n        if (!local) {\n          // TODO: Add this message to the logging:\n          //       \"Pass { local: true } to disable this warning and only do local queries.\"\n          console.log(\n            `No \"${PARAMS}\" or \"${FETCH_PARAMS}\" attribute was found in the makeFindMixin for the \"${service}\" service (using name \"${nameToUse}\").  No queries will be made.`\n          )\n        }\n      }\n    }\n  }\n  function hasSomeAttribute(vm, ...attributes) {\n    return attributes.some(a => {\n      return vm.hasOwnProperty(a) || Object.getPrototypeOf(vm).hasOwnProperty(a)\n    })\n  }\n  function setupAttribute(\n    NAME,\n    value,\n    computedOrMethods = 'computed',\n    returnTheValue = false\n  ) {\n    if (typeof value === 'boolean') {\n      data[NAME] = !!value\n    } else if (typeof value === 'string') {\n      mixin.computed[NAME] = function() {\n        // If the specified computed prop wasn't found, display an error.\n        if (!returnTheValue) {\n          if (!hasSomeAttribute(this, value, NAME)) {\n            throw new Error(\n              `Value for ${NAME} was not found on the component at '${value}'.`\n            )\n          }\n        }\n        return returnTheValue ? value : this[value]\n      }\n    } else if (typeof value === 'function') {\n      mixin[computedOrMethods][NAME] = value\n    }\n  }\n  setupAttribute(SERVICE_NAME, service, 'computed', true)\n  setupAttribute(PARAMS, params)\n  setupAttribute(FETCH_PARAMS, fetchQuery)\n  setupAttribute(QUERY_WHEN, queryWhen, 'computed')\n  setupAttribute(LOCAL, local)\n  return mixin\n}\n"]}]}