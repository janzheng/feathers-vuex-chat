{"remainingRequest":"/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/babel-loader/lib/index.js!/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/feathers-vuex/dist/service-module/make-service-plugin.js","dependencies":[{"path":"/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/feathers-vuex/dist/service-module/make-service-plugin.js","mtime":1576553531990},{"path":"/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/cache-loader/dist/cjs.js","mtime":1576617922850},{"path":"/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/babel-loader/lib/index.js","mtime":1572970632149}],"contextDependencies":[],"result":["import makeServiceModule from \"./make-service-module\";\nimport { globalModels, prepareAddModel } from \"./global-models\";\nimport { makeNamespace, getServicePath, assignIfNotPresent } from \"../utils\";\nimport _get from 'lodash/get';\nvar defaults = {\n  namespace: '',\n  nameStyle: 'short',\n  servicePath: '',\n  state: {},\n  getters: {},\n  mutations: {},\n  actions: {},\n  instanceDefaults: function instanceDefaults() {\n    return {};\n  },\n  setupInstance: function setupInstance(instance) {\n    return instance;\n  } // Default setupInstance returns the instance\n\n};\n/**\n * prepare only wraps the makeServicePlugin to provide the globalOptions.\n * @param globalOptions\n */\n\nexport default function prepareMakeServicePlugin(globalOptions) {\n  var addModel = prepareAddModel(globalOptions);\n  /**\n   * (1) Make a Vuex plugin for the provided service.\n   * (2a) Attach the vuex store to the BaseModel.\n   * (2b) If the Model does not extend the BaseModel, monkey patch it, too\n   * (3) Setup real-time events\n   */\n\n  return function makeServicePlugin(config) {\n    var options = Object.assign({}, defaults, globalOptions, config);\n    var Model = options.Model,\n        service = options.service,\n        namespace = options.namespace,\n        nameStyle = options.nameStyle,\n        instanceDefaults = options.instanceDefaults,\n        setupInstance = options.setupInstance,\n        preferUpdate = options.preferUpdate;\n\n    if (!service) {\n      throw new Error('No service was provided. If you passed one in, check that you have configured a transport plugin on the Feathers Client. Make sure you use the client version of the transport.');\n    } // Make sure we get a service path from either the service or the options\n\n\n    var servicePath = options.servicePath;\n\n    if (!servicePath) {\n      servicePath = getServicePath(service, Model);\n    }\n\n    options.servicePath = servicePath;\n    service.FeathersVuexModel = Model;\n    return function (store) {\n      // (1^) Create and register the Vuex module\n      options.namespace = makeNamespace(namespace, servicePath, nameStyle);\n      var module = makeServiceModule(service, options);\n      store.registerModule(options.namespace, module); // (2a^) Monkey patch the BaseModel in globalModels\n\n      var BaseModel = _get(globalModels, \"[\".concat(options.serverAlias, \"].BaseModel\"));\n\n      if (BaseModel && !BaseModel.store) {\n        Object.assign(BaseModel, {\n          store: store\n        });\n      } // (2b^) Monkey patch the Model(s) and add to globalModels\n\n\n      assignIfNotPresent(Model, {\n        store: store,\n        namespace: options.namespace,\n        servicePath: servicePath,\n        instanceDefaults: instanceDefaults,\n        setupInstance: setupInstance,\n        preferUpdate: preferUpdate\n      });\n\n      if (!Model.modelName || Model.modelName === 'BaseModel') {\n        throw new Error('The modelName property is required for Feathers-Vuex Models');\n      }\n\n      addModel(Model); // (3^) Setup real-time events\n\n      if (options.enableEvents) {\n        // Listen to socket events when available.\n        service.on('created', function (item) {\n          store.dispatch(\"\".concat(options.namespace, \"/addOrUpdate\"), item);\n\n          if (Model.emit) {\n            Model.emit('created', item);\n          }\n        });\n        service.on('updated', function (item) {\n          store.dispatch(\"\".concat(options.namespace, \"/addOrUpdate\"), item);\n\n          if (Model.emit) {\n            Model.emit('updated', item);\n          }\n        });\n        service.on('patched', function (item) {\n          store.dispatch(\"\".concat(options.namespace, \"/addOrUpdate\"), item);\n\n          if (Model.emit) {\n            Model.emit('patched', item);\n          }\n        });\n        service.on('removed', function (item) {\n          store.commit(\"\".concat(options.namespace, \"/removeItem\"), item);\n\n          if (Model.emit) {\n            Model.emit('removed', item);\n          }\n        });\n      }\n    };\n  };\n}",{"version":3,"sources":["/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/feathers-vuex/dist/service-module/make-service-plugin.js"],"names":["makeServiceModule","globalModels","prepareAddModel","makeNamespace","getServicePath","assignIfNotPresent","_get","defaults","namespace","nameStyle","servicePath","state","getters","mutations","actions","instanceDefaults","setupInstance","instance","prepareMakeServicePlugin","globalOptions","addModel","makeServicePlugin","config","options","Object","assign","Model","service","preferUpdate","Error","FeathersVuexModel","store","module","registerModule","BaseModel","serverAlias","modelName","enableEvents","on","item","dispatch","emit","commit"],"mappings":"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","sourcesContent":["import makeServiceModule from './make-service-module'\nimport { globalModels, prepareAddModel } from './global-models'\nimport { makeNamespace, getServicePath, assignIfNotPresent } from '../utils'\nimport _get from 'lodash/get'\nconst defaults = {\n  namespace: '',\n  nameStyle: 'short',\n  servicePath: '',\n  state: {},\n  getters: {},\n  mutations: {},\n  actions: {},\n  instanceDefaults: () => ({}),\n  setupInstance: instance => instance // Default setupInstance returns the instance\n}\n/**\n * prepare only wraps the makeServicePlugin to provide the globalOptions.\n * @param globalOptions\n */\nexport default function prepareMakeServicePlugin(globalOptions) {\n  const addModel = prepareAddModel(globalOptions)\n  /**\n   * (1) Make a Vuex plugin for the provided service.\n   * (2a) Attach the vuex store to the BaseModel.\n   * (2b) If the Model does not extend the BaseModel, monkey patch it, too\n   * (3) Setup real-time events\n   */\n  return function makeServicePlugin(config) {\n    const options = Object.assign({}, defaults, globalOptions, config)\n    const {\n      Model,\n      service,\n      namespace,\n      nameStyle,\n      instanceDefaults,\n      setupInstance,\n      preferUpdate\n    } = options\n    if (!service) {\n      throw new Error(\n        'No service was provided. If you passed one in, check that you have configured a transport plugin on the Feathers Client. Make sure you use the client version of the transport.'\n      )\n    }\n    // Make sure we get a service path from either the service or the options\n    let { servicePath } = options\n    if (!servicePath) {\n      servicePath = getServicePath(service, Model)\n    }\n    options.servicePath = servicePath\n    service.FeathersVuexModel = Model\n    return store => {\n      // (1^) Create and register the Vuex module\n      options.namespace = makeNamespace(namespace, servicePath, nameStyle)\n      const module = makeServiceModule(service, options)\n      store.registerModule(options.namespace, module)\n      // (2a^) Monkey patch the BaseModel in globalModels\n      const BaseModel = _get(globalModels, `[${options.serverAlias}].BaseModel`)\n      if (BaseModel && !BaseModel.store) {\n        Object.assign(BaseModel, {\n          store\n        })\n      }\n      // (2b^) Monkey patch the Model(s) and add to globalModels\n      assignIfNotPresent(Model, {\n        store,\n        namespace: options.namespace,\n        servicePath,\n        instanceDefaults,\n        setupInstance,\n        preferUpdate\n      })\n      if (!Model.modelName || Model.modelName === 'BaseModel') {\n        throw new Error(\n          'The modelName property is required for Feathers-Vuex Models'\n        )\n      }\n      addModel(Model)\n      // (3^) Setup real-time events\n      if (options.enableEvents) {\n        // Listen to socket events when available.\n        service.on('created', item => {\n          store.dispatch(`${options.namespace}/addOrUpdate`, item)\n          if (Model.emit) {\n            Model.emit('created', item)\n          }\n        })\n        service.on('updated', item => {\n          store.dispatch(`${options.namespace}/addOrUpdate`, item)\n          if (Model.emit) {\n            Model.emit('updated', item)\n          }\n        })\n        service.on('patched', item => {\n          store.dispatch(`${options.namespace}/addOrUpdate`, item)\n          if (Model.emit) {\n            Model.emit('patched', item)\n          }\n        })\n        service.on('removed', item => {\n          store.commit(`${options.namespace}/removeItem`, item)\n          if (Model.emit) {\n            Model.emit('removed', item)\n          }\n        })\n      }\n    }\n  }\n}\n"]}]}