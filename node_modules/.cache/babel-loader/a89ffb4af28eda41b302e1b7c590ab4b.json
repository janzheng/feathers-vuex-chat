{"remainingRequest":"/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/babel-loader/lib/index.js!/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/feathers-vuex/dist/auth-module/auth-module.actions.js","dependencies":[{"path":"/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/feathers-vuex/dist/auth-module/auth-module.actions.js","mtime":1576553531990},{"path":"/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/cache-loader/dist/cjs.js","mtime":1576617922850},{"path":"/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/babel-loader/lib/index.js","mtime":1572970632149}],"contextDependencies":[],"result":["import \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.object.keys\";\nimport \"core-js/modules/es6.array.find\";\n\n/*\neslint\n@typescript-eslint/explicit-function-return-type: 0,\n@typescript-eslint/no-explicit-any: 0\n*/\nimport { globalModels as models } from \"../service-module/global-models\";\nexport default function makeAuthActions(feathersClient) {\n  return {\n    authenticate: function authenticate(store, data) {\n      var commit = store.commit,\n          state = store.state,\n          dispatch = store.dispatch;\n      commit('setAuthenticatePending');\n\n      if (state.errorOnAuthenticate) {\n        commit('clearAuthenticateError');\n      }\n\n      return feathersClient.authenticate(data).then(function (response) {\n        return dispatch('responseHandler', response);\n      }).catch(function (error) {\n        commit('setAuthenticateError', error);\n        commit('unsetAuthenticatePending');\n        return Promise.reject(error);\n      });\n    },\n    responseHandler: function responseHandler(_ref, response) {\n      var commit = _ref.commit,\n          state = _ref.state,\n          dispatch = _ref.dispatch;\n\n      if (response.accessToken) {\n        commit('setAccessToken', response.accessToken);\n        commit('setPayload', response); // Handle when user is returned in the authenticate response\n\n        var user = response[state.responseEntityField];\n\n        if (user) {\n          if (state.serverAlias && state.userService) {\n            var Model = Object.keys(models[state.serverAlias]).map(function (modelName) {\n              return models[state.serverAlias][modelName];\n            }).find(function (model) {\n              return model.servicePath === state.userService;\n            });\n\n            if (Model) {\n              user = new Model(user);\n            }\n          }\n\n          commit('setUser', user);\n          commit('unsetAuthenticatePending');\n        } else if (state.userService && response.hasOwnProperty(state.entityIdField)) {\n          return dispatch('populateUser', response[state.entityIdField]).then(function () {\n            commit('unsetAuthenticatePending');\n            return response;\n          });\n        }\n\n        return response; // If there was not an accessToken in the response, allow the response to pass through to handle two-factor-auth\n      } else {\n        return response;\n      }\n    },\n    populateUser: function populateUser(_ref2, userId) {\n      var commit = _ref2.commit,\n          state = _ref2.state,\n          dispatch = _ref2.dispatch;\n      return dispatch(\"\".concat(state.userService, \"/get\"), userId, {\n        root: true\n      }).then(function (user) {\n        commit('setUser', user);\n        return user;\n      });\n    },\n    logout: function logout(_ref3) {\n      var commit = _ref3.commit;\n      commit('setLogoutPending');\n      return feathersClient.logout().then(function (response) {\n        commit('logout');\n        commit('unsetLogoutPending');\n        return response;\n      }).catch(function (error) {\n        return Promise.reject(error);\n      });\n    }\n  };\n}",{"version":3,"sources":["/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/feathers-vuex/dist/auth-module/auth-module.actions.js"],"names":["globalModels","models","makeAuthActions","feathersClient","authenticate","store","data","commit","state","dispatch","errorOnAuthenticate","then","response","catch","error","Promise","reject","responseHandler","accessToken","user","responseEntityField","serverAlias","userService","Model","Object","keys","map","modelName","find","model","servicePath","hasOwnProperty","entityIdField","populateUser","userId","root","logout"],"mappings":"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","sourcesContent":["/*\neslint\n@typescript-eslint/explicit-function-return-type: 0,\n@typescript-eslint/no-explicit-any: 0\n*/\nimport { globalModels as models } from '../service-module/global-models'\nexport default function makeAuthActions(feathersClient) {\n  return {\n    authenticate(store, data) {\n      const { commit, state, dispatch } = store\n      commit('setAuthenticatePending')\n      if (state.errorOnAuthenticate) {\n        commit('clearAuthenticateError')\n      }\n      return feathersClient\n        .authenticate(data)\n        .then(response => {\n          return dispatch('responseHandler', response)\n        })\n        .catch(error => {\n          commit('setAuthenticateError', error)\n          commit('unsetAuthenticatePending')\n          return Promise.reject(error)\n        })\n    },\n    responseHandler({ commit, state, dispatch }, response) {\n      if (response.accessToken) {\n        commit('setAccessToken', response.accessToken)\n        commit('setPayload', response)\n        // Handle when user is returned in the authenticate response\n        let user = response[state.responseEntityField]\n        if (user) {\n          if (state.serverAlias && state.userService) {\n            const Model = Object.keys(models[state.serverAlias])\n              .map(modelName => models[state.serverAlias][modelName])\n              .find(model => model.servicePath === state.userService)\n            if (Model) {\n              user = new Model(user)\n            }\n          }\n          commit('setUser', user)\n          commit('unsetAuthenticatePending')\n        } else if (\n          state.userService &&\n          response.hasOwnProperty(state.entityIdField)\n        ) {\n          return dispatch('populateUser', response[state.entityIdField]).then(\n            () => {\n              commit('unsetAuthenticatePending')\n              return response\n            }\n          )\n        }\n        return response\n        // If there was not an accessToken in the response, allow the response to pass through to handle two-factor-auth\n      } else {\n        return response\n      }\n    },\n    populateUser({ commit, state, dispatch }, userId) {\n      return dispatch(`${state.userService}/get`, userId, { root: true }).then(\n        user => {\n          commit('setUser', user)\n          return user\n        }\n      )\n    },\n    logout({ commit }) {\n      commit('setLogoutPending')\n      return feathersClient\n        .logout()\n        .then(response => {\n          commit('logout')\n          commit('unsetLogoutPending')\n          return response\n        })\n        .catch(error => {\n          return Promise.reject(error)\n        })\n    }\n  }\n}\n"]}]}