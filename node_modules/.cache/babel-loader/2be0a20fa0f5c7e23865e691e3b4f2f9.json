{"remainingRequest":"/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/babel-loader/lib/index.js!/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/feathers-vuex/dist/service-module/service-module.mutations.js","dependencies":[{"path":"/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/feathers-vuex/dist/service-module/service-module.mutations.js","mtime":1576553531990},{"path":"/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/cache-loader/dist/cjs.js","mtime":1576617922850},{"path":"/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/babel-loader/lib/index.js","mtime":1572970632149}],"contextDependencies":[],"result":["import _defineProperty from \"/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport \"core-js/modules/es6.object.keys\";\nimport \"core-js/modules/es6.array.sort\";\nimport \"core-js/modules/es6.array.find-index\";\nimport \"core-js/modules/es7.array.includes\";\nimport \"core-js/modules/es6.string.includes\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\n\n/*\neslint\n@typescript-eslint/explicit-function-return-type: 0,\n@typescript-eslint/no-explicit-any: 0\n*/\nimport Vue from 'vue';\nimport { serializeError } from 'serialize-error';\nimport { updateOriginal, mergeWithAccessors, assignTempId, getId, getQueryInfo } from \"../utils\";\nimport { globalModels as models } from \"./global-models\";\nimport _omit from 'lodash/omit';\nimport _get from 'lodash/get';\nimport _isObject from 'lodash/isObject';\nexport default function makeServiceMutations() {\n  function addItems(state, items) {\n    var serverAlias = state.serverAlias,\n        idField = state.idField,\n        tempIdField = state.tempIdField,\n        modelName = state.modelName;\n\n    var Model = _get(models, \"[\".concat(serverAlias, \"][\").concat(modelName, \"]\"));\n\n    var BaseModel = _get(models, \"[\".concat(state.serverAlias, \"].BaseModel\"));\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var item = _step.value;\n        var id = getId(item, idField);\n        var isTemp = id === null || id === undefined; // If the response contains a real id, remove isTemp\n\n        if (id != null) {\n          delete item.__isTemp;\n        }\n\n        if (Model && !(item instanceof BaseModel) && !(item instanceof Model)) {\n          item = new Model(item);\n        }\n\n        if (isTemp) {\n          var tempId = item[tempIdField];\n\n          if (tempId == null) {\n            tempId = assignTempId(state, item);\n          }\n\n          item.__isTemp = true;\n          Vue.set(state.tempsById, tempId, item);\n        } else {\n          // Only add the id if it's not already in the `ids` list.\n          if (!state.ids.includes(id)) {\n            state.ids.push(id);\n          }\n\n          Vue.set(state.keyedById, id, item);\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }\n\n  function _updateItems(state, items) {\n    var idField = state.idField,\n        replaceItems = state.replaceItems,\n        addOnUpsert = state.addOnUpsert,\n        serverAlias = state.serverAlias,\n        modelName = state.modelName;\n\n    var Model = _get(models, \"[\".concat(serverAlias, \"][\").concat(modelName, \"]\"));\n\n    var BaseModel = _get(models, \"[\".concat(state.serverAlias, \"].BaseModel\"));\n\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = items[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var item = _step2.value;\n        var id = getId(item, idField); // If the response contains a real id, remove isTemp\n\n        if (id != null) {\n          delete item.__isTemp;\n        } // Update the record\n\n\n        if (id !== null && id !== undefined) {\n          if (state.ids.includes(id)) {\n            // Completely replace the item\n            if (replaceItems) {\n              if (Model && !item.isFeathersVuexInstance) {\n                item = new Model(item);\n              }\n\n              Vue.set(state.keyedById, id, item); // Merge in changes\n            } else {\n              /**\n               * If we have a Model class, calling new Model(incomingData) will call update\n               * the original record with the accessors and setupInstance data.\n               * This means that date objects and relationships will be preserved.\n               *\n               * If there's no Model class, just call updateOriginal on the incoming data.\n               */\n              if (Model && !(item instanceof BaseModel) && !(item instanceof Model)) {\n                item = new Model(item);\n              }\n\n              var original = state.keyedById[id];\n              updateOriginal(original, item);\n            } // if addOnUpsert then add the record into the state, else discard it.\n\n          } else if (addOnUpsert) {\n            state.ids.push(id);\n            Vue.set(state.keyedById, id, item);\n          }\n\n          continue;\n        }\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  }\n\n  function mergeInstance(state, item) {\n    var serverAlias = state.serverAlias,\n        idField = state.idField,\n        tempIdField = state.tempIdField,\n        modelName = state.modelName;\n    var id = getId(item, idField);\n    var existingItem = state.keyedById[id];\n\n    if (existingItem) {\n      mergeWithAccessors(existingItem, item);\n    }\n  }\n\n  function merge(state, _ref) {\n    var dest = _ref.dest,\n        source = _ref.source;\n    mergeWithAccessors(dest, source);\n  }\n\n  return {\n    mergeInstance: mergeInstance,\n    merge: merge,\n    addItem: function addItem(state, item) {\n      addItems(state, [item]);\n    },\n    addItems: addItems,\n    updateItem: function updateItem(state, item) {\n      _updateItems(state, [item]);\n    },\n    updateItems: function updateItems(state, items) {\n      if (!Array.isArray(items)) {\n        throw new Error('You must provide an array to the `updateItems` mutation.');\n      }\n\n      _updateItems(state, items);\n    },\n    // Adds an _id to a temp record so that that the addOrUpdate action\n    // can migrate the temp to the keyedById state.\n    updateTemp: function updateTemp(state, _ref2) {\n      var id = _ref2.id,\n          tempId = _ref2.tempId;\n      var temp = state.tempsById[tempId];\n\n      if (state.tempsById) {\n        temp[state.idField] = id;\n        state.tempsByNewId[id] = temp;\n      }\n    },\n\n    /**\n     * Overwrites the item with matching id with the temp record.\n     * This is to preserve reactivity for temp records.\n     */\n    replaceItemWithTemp: function replaceItemWithTemp(state, _ref3) {\n      var item = _ref3.item,\n          temp = _ref3.temp;\n      var id = item[state.idField];\n\n      if (state.keyedById[id]) {\n        state.keyedById[id] = temp;\n        Vue.delete(state.keyedById[id], '__isTemp');\n      }\n    },\n    remove__isTemp: function remove__isTemp(state, temp) {\n      Vue.delete(temp, '__isTemp');\n    },\n    removeItem: function removeItem(state, item) {\n      var idField = state.idField;\n      var idToBeRemoved = _isObject(item) ? getId(item, idField) : item;\n      var isIdOk = idToBeRemoved !== null && idToBeRemoved !== undefined;\n      var index = state.ids.findIndex(function (i) {\n        return i === idToBeRemoved;\n      });\n\n      if (isIdOk && index !== null && index !== undefined) {\n        Vue.delete(state.ids, index);\n        Vue.delete(state.keyedById, idToBeRemoved);\n      }\n    },\n    // Removes temp records. Also cleans up tempsByNewId\n    removeTemps: function removeTemps(state, tempIds) {\n      var ids = tempIds.reduce(function (ids, id) {\n        var temp = state.tempsById[id];\n\n        if (temp && temp[state.idField]) {\n          delete temp.__isTemp;\n          Vue.delete(temp, '__isTemp');\n          ids.push(temp[state.idField]);\n        }\n\n        return ids;\n      }, []);\n      state.tempsByNewId = _omit(state.tempsByNewId, ids);\n      state.tempsById = _omit(state.tempsById, tempIds);\n    },\n    removeItems: function removeItems(state, items) {\n      var idField = state.idField;\n\n      if (!Array.isArray(items)) {\n        throw new Error('You must provide an array to the `removeItems` mutation.');\n      } // Make sure we have an array of ids. Assume all are the same.\n\n\n      var containsObjects = items[0] && _isObject(items[0]);\n\n      var idsToRemove = containsObjects ? items.map(function (item) {\n        return getId(item, idField);\n      }) : items;\n      var mapOfIdsToRemove = idsToRemove.reduce(function (map, id) {\n        map[id] = true;\n        return map;\n      }, {});\n      idsToRemove.forEach(function (id) {\n        Vue.delete(state.keyedById, id);\n      }); // Get indexes to remove from the ids array.\n\n      var mapOfIndexesToRemove = state.ids.reduce(function (map, id, index) {\n        if (mapOfIdsToRemove[id]) {\n          map[index] = true;\n        }\n\n        return map;\n      }, {}); // Remove highest indexes first, so the indexes don't change\n\n      var indexesInReverseOrder = Object.keys(mapOfIndexesToRemove).sort(function (a, b) {\n        if (a < b) {\n          return 1;\n        } else if (a > b) {\n          return -1;\n        } else {\n          return 0;\n        }\n      });\n      indexesInReverseOrder.forEach(function (indexInIdsArray) {\n        Vue.delete(state.ids, indexInIdsArray);\n      });\n    },\n    clearAll: function clearAll(state) {\n      state.ids = [];\n      state.keyedById = {};\n    },\n    // Creates a copy of the record with the passed-in id, stores it in copiesById\n    createCopy: function createCopy(state, id) {\n      var servicePath = state.servicePath,\n          keepCopiesInStore = state.keepCopiesInStore,\n          serverAlias = state.serverAlias;\n      var current = state.keyedById[id] || state.tempsById[id];\n\n      var Model = _get(models, \"[\".concat(serverAlias, \"].byServicePath[\").concat(servicePath, \"]\"));\n\n      if (Model) {\n        var model = new Model(current, {\n          clone: true\n        });\n      } else {\n        var copyData = mergeWithAccessors({}, current);\n      }\n\n      var item = model || copyData;\n\n      if (keepCopiesInStore) {\n        state.copiesById[id] = item;\n      } else {\n        // Since it won't be added to the store, make it a Vue object\n        if (!item.hasOwnProperty('__ob__')) {\n          item = Vue.observable(item);\n        }\n\n        Model.copiesById[id] = item;\n      }\n    },\n    // Resets the copy to match the original record, locally\n    resetCopy: function resetCopy(state, id) {\n      var servicePath = state.servicePath,\n          keepCopiesInStore = state.keepCopiesInStore;\n\n      var Model = _get(models, \"[\".concat(state.serverAlias, \"].byServicePath[\").concat(servicePath, \"]\"));\n\n      var copy = keepCopiesInStore ? state.copiesById[id] : Model && _get(Model, \"copiesById[\".concat(id, \"]\"));\n\n      if (copy) {\n        var original = copy[state.idField] != null ? state.keyedById[id] : state.tempsById[id];\n        mergeWithAccessors(copy, original);\n      }\n    },\n    // Deep assigns copy to original record, locally\n    commitCopy: function commitCopy(state, id) {\n      var servicePath = state.servicePath,\n          keepCopiesInStore = state.keepCopiesInStore;\n\n      var Model = _get(models, \"[\".concat(state.serverAlias, \"].byServicePath[\").concat(servicePath, \"]\"));\n\n      var copy = keepCopiesInStore ? state.copiesById[id] : Model && _get(Model, \"copiesById[\".concat(id, \"]\"));\n\n      if (copy) {\n        var original = copy[state.idField] != null ? state.keyedById[id] : state.tempsById[id];\n        mergeWithAccessors(original, copy);\n      }\n    },\n    // Removes the copy from copiesById\n    clearCopy: function clearCopy(state, id) {\n      var newCopiesById = Object.assign({}, state.copiesById);\n      delete newCopiesById[id];\n      state.copiesById = newCopiesById;\n    },\n\n    /**\n     * Stores pagination data on state.pagination based on the query identifier\n     * (qid) The qid must be manually assigned to `params.qid`\n     */\n    updatePaginationForQuery: function updatePaginationForQuery(state, _ref4) {\n      var qid = _ref4.qid,\n          response = _ref4.response,\n          _ref4$query = _ref4.query,\n          query = _ref4$query === void 0 ? {} : _ref4$query;\n      var data = response.data,\n          total = response.total;\n      var idField = state.idField;\n      var ids = data.map(function (i) {\n        return i[idField];\n      });\n      var queriedAt = new Date().getTime();\n\n      var _getQueryInfo = getQueryInfo({\n        qid: qid,\n        query: query\n      }, response),\n          queryId = _getQueryInfo.queryId,\n          queryParams = _getQueryInfo.queryParams,\n          pageId = _getQueryInfo.pageId,\n          pageParams = _getQueryInfo.pageParams;\n\n      if (!state.pagination[qid]) {\n        Vue.set(state.pagination, qid, {});\n      }\n\n      if (!query.hasOwnProperty('$limit') && response.hasOwnProperty('limit')) {\n        Vue.set(state.pagination, 'defaultLimit', response.limit);\n      }\n\n      if (!query.hasOwnProperty('$skip') && response.hasOwnProperty('skip')) {\n        Vue.set(state.pagination, 'defaultSkip', response.skip);\n      }\n\n      var mostRecent = {\n        query: query,\n        queryId: queryId,\n        queryParams: queryParams,\n        pageId: pageId,\n        pageParams: pageParams,\n        queriedAt: queriedAt,\n        total: total\n      };\n      var qidData = state.pagination[qid] || {};\n      Object.assign(qidData, {\n        mostRecent: mostRecent\n      });\n      qidData[queryId] = qidData[queryId] || {};\n      var queryData = {\n        total: total,\n        queryParams: queryParams\n      };\n      Object.assign(qidData[queryId], queryData);\n\n      var pageData = _defineProperty({}, pageId, {\n        pageParams: pageParams,\n        ids: ids,\n        queriedAt: queriedAt\n      });\n\n      Object.assign(qidData[queryId], pageData);\n      var newState = Object.assign({}, state.pagination[qid], qidData);\n      Vue.set(state.pagination, qid, newState);\n    },\n    setPending: function setPending(state, method) {\n      var uppercaseMethod = method.charAt(0).toUpperCase() + method.slice(1);\n      state[\"is\".concat(uppercaseMethod, \"Pending\")] = true;\n    },\n    unsetPending: function unsetPending(state, method) {\n      var uppercaseMethod = method.charAt(0).toUpperCase() + method.slice(1);\n      state[\"is\".concat(uppercaseMethod, \"Pending\")] = false;\n    },\n    setError: function setError(state, payload) {\n      var method = payload.method,\n          error = payload.error;\n      var uppercaseMethod = method.charAt(0).toUpperCase() + method.slice(1);\n      state[\"errorOn\".concat(uppercaseMethod)] = Object.assign({}, serializeError(error));\n    },\n    clearError: function clearError(state, method) {\n      var uppercaseMethod = method.charAt(0).toUpperCase() + method.slice(1);\n      state[\"errorOn\".concat(uppercaseMethod)] = null;\n    }\n  };\n}",{"version":3,"sources":["/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/feathers-vuex/dist/service-module/service-module.mutations.js"],"names":["Vue","serializeError","updateOriginal","mergeWithAccessors","assignTempId","getId","getQueryInfo","globalModels","models","_omit","_get","_isObject","makeServiceMutations","addItems","state","items","serverAlias","idField","tempIdField","modelName","Model","BaseModel","item","id","isTemp","undefined","__isTemp","tempId","set","tempsById","ids","includes","push","keyedById","updateItems","replaceItems","addOnUpsert","isFeathersVuexInstance","original","mergeInstance","existingItem","merge","dest","source","addItem","updateItem","Array","isArray","Error","updateTemp","temp","tempsByNewId","replaceItemWithTemp","delete","remove__isTemp","removeItem","idToBeRemoved","isIdOk","index","findIndex","i","removeTemps","tempIds","reduce","removeItems","containsObjects","idsToRemove","map","mapOfIdsToRemove","forEach","mapOfIndexesToRemove","indexesInReverseOrder","Object","keys","sort","a","b","indexInIdsArray","clearAll","createCopy","servicePath","keepCopiesInStore","current","model","clone","copyData","copiesById","hasOwnProperty","observable","resetCopy","copy","commitCopy","clearCopy","newCopiesById","assign","updatePaginationForQuery","qid","response","query","data","total","queriedAt","Date","getTime","queryId","queryParams","pageId","pageParams","pagination","limit","skip","mostRecent","qidData","queryData","pageData","newState","setPending","method","uppercaseMethod","charAt","toUpperCase","slice","unsetPending","setError","payload","error","clearError"],"mappings":"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","sourcesContent":["/*\neslint\n@typescript-eslint/explicit-function-return-type: 0,\n@typescript-eslint/no-explicit-any: 0\n*/\nimport Vue from 'vue'\nimport { serializeError } from 'serialize-error'\nimport {\n  updateOriginal,\n  mergeWithAccessors,\n  assignTempId,\n  getId,\n  getQueryInfo\n} from '../utils'\nimport { globalModels as models } from './global-models'\nimport _omit from 'lodash/omit'\nimport _get from 'lodash/get'\nimport _isObject from 'lodash/isObject'\nexport default function makeServiceMutations() {\n  function addItems(state, items) {\n    const { serverAlias, idField, tempIdField, modelName } = state\n    const Model = _get(models, `[${serverAlias}][${modelName}]`)\n    const BaseModel = _get(models, `[${state.serverAlias}].BaseModel`)\n    for (let item of items) {\n      const id = getId(item, idField)\n      const isTemp = id === null || id === undefined\n      // If the response contains a real id, remove isTemp\n      if (id != null) {\n        delete item.__isTemp\n      }\n      if (Model && !(item instanceof BaseModel) && !(item instanceof Model)) {\n        item = new Model(item)\n      }\n      if (isTemp) {\n        let tempId = item[tempIdField]\n        if (tempId == null) {\n          tempId = assignTempId(state, item)\n        }\n        item.__isTemp = true\n        Vue.set(state.tempsById, tempId, item)\n      } else {\n        // Only add the id if it's not already in the `ids` list.\n        if (!state.ids.includes(id)) {\n          state.ids.push(id)\n        }\n        Vue.set(state.keyedById, id, item)\n      }\n    }\n  }\n  function updateItems(state, items) {\n    const { idField, replaceItems, addOnUpsert, serverAlias, modelName } = state\n    const Model = _get(models, `[${serverAlias}][${modelName}]`)\n    const BaseModel = _get(models, `[${state.serverAlias}].BaseModel`)\n    for (let item of items) {\n      const id = getId(item, idField)\n      // If the response contains a real id, remove isTemp\n      if (id != null) {\n        delete item.__isTemp\n      }\n      // Update the record\n      if (id !== null && id !== undefined) {\n        if (state.ids.includes(id)) {\n          // Completely replace the item\n          if (replaceItems) {\n            if (Model && !item.isFeathersVuexInstance) {\n              item = new Model(item)\n            }\n            Vue.set(state.keyedById, id, item)\n            // Merge in changes\n          } else {\n            /**\n             * If we have a Model class, calling new Model(incomingData) will call update\n             * the original record with the accessors and setupInstance data.\n             * This means that date objects and relationships will be preserved.\n             *\n             * If there's no Model class, just call updateOriginal on the incoming data.\n             */\n            if (\n              Model &&\n              !(item instanceof BaseModel) &&\n              !(item instanceof Model)\n            ) {\n              item = new Model(item)\n            }\n            const original = state.keyedById[id]\n            updateOriginal(original, item)\n          }\n          // if addOnUpsert then add the record into the state, else discard it.\n        } else if (addOnUpsert) {\n          state.ids.push(id)\n          Vue.set(state.keyedById, id, item)\n        }\n        continue\n      }\n    }\n  }\n  function mergeInstance(state, item) {\n    const { serverAlias, idField, tempIdField, modelName } = state\n    const id = getId(item, idField)\n    const existingItem = state.keyedById[id]\n    if (existingItem) {\n      mergeWithAccessors(existingItem, item)\n    }\n  }\n  function merge(state, { dest, source }) {\n    mergeWithAccessors(dest, source)\n  }\n  return {\n    mergeInstance,\n    merge,\n    addItem(state, item) {\n      addItems(state, [item])\n    },\n    addItems,\n    updateItem(state, item) {\n      updateItems(state, [item])\n    },\n    updateItems(state, items) {\n      if (!Array.isArray(items)) {\n        throw new Error(\n          'You must provide an array to the `updateItems` mutation.'\n        )\n      }\n      updateItems(state, items)\n    },\n    // Adds an _id to a temp record so that that the addOrUpdate action\n    // can migrate the temp to the keyedById state.\n    updateTemp(state, { id, tempId }) {\n      const temp = state.tempsById[tempId]\n      if (state.tempsById) {\n        temp[state.idField] = id\n        state.tempsByNewId[id] = temp\n      }\n    },\n    /**\n     * Overwrites the item with matching id with the temp record.\n     * This is to preserve reactivity for temp records.\n     */\n    replaceItemWithTemp(state, { item, temp }) {\n      const id = item[state.idField]\n      if (state.keyedById[id]) {\n        state.keyedById[id] = temp\n        Vue.delete(state.keyedById[id], '__isTemp')\n      }\n    },\n    remove__isTemp(state, temp) {\n      Vue.delete(temp, '__isTemp')\n    },\n    removeItem(state, item) {\n      const { idField } = state\n      const idToBeRemoved = _isObject(item) ? getId(item, idField) : item\n      const isIdOk = idToBeRemoved !== null && idToBeRemoved !== undefined\n      const index = state.ids.findIndex(i => i === idToBeRemoved)\n      if (isIdOk && index !== null && index !== undefined) {\n        Vue.delete(state.ids, index)\n        Vue.delete(state.keyedById, idToBeRemoved)\n      }\n    },\n    // Removes temp records. Also cleans up tempsByNewId\n    removeTemps(state, tempIds) {\n      const ids = tempIds.reduce((ids, id) => {\n        const temp = state.tempsById[id]\n        if (temp && temp[state.idField]) {\n          delete temp.__isTemp\n          Vue.delete(temp, '__isTemp')\n          ids.push(temp[state.idField])\n        }\n        return ids\n      }, [])\n      state.tempsByNewId = _omit(state.tempsByNewId, ids)\n      state.tempsById = _omit(state.tempsById, tempIds)\n    },\n    removeItems(state, items) {\n      const { idField } = state\n      if (!Array.isArray(items)) {\n        throw new Error(\n          'You must provide an array to the `removeItems` mutation.'\n        )\n      }\n      // Make sure we have an array of ids. Assume all are the same.\n      const containsObjects = items[0] && _isObject(items[0])\n      const idsToRemove = containsObjects\n        ? items.map(item => getId(item, idField))\n        : items\n      const mapOfIdsToRemove = idsToRemove.reduce((map, id) => {\n        map[id] = true\n        return map\n      }, {})\n      idsToRemove.forEach(id => {\n        Vue.delete(state.keyedById, id)\n      })\n      // Get indexes to remove from the ids array.\n      const mapOfIndexesToRemove = state.ids.reduce((map, id, index) => {\n        if (mapOfIdsToRemove[id]) {\n          map[index] = true\n        }\n        return map\n      }, {})\n      // Remove highest indexes first, so the indexes don't change\n      const indexesInReverseOrder = Object.keys(mapOfIndexesToRemove).sort(\n        (a, b) => {\n          if (a < b) {\n            return 1\n          } else if (a > b) {\n            return -1\n          } else {\n            return 0\n          }\n        }\n      )\n      indexesInReverseOrder.forEach(indexInIdsArray => {\n        Vue.delete(state.ids, indexInIdsArray)\n      })\n    },\n    clearAll(state) {\n      state.ids = []\n      state.keyedById = {}\n    },\n    // Creates a copy of the record with the passed-in id, stores it in copiesById\n    createCopy(state, id) {\n      const { servicePath, keepCopiesInStore, serverAlias } = state\n      const current = state.keyedById[id] || state.tempsById[id]\n      const Model = _get(\n        models,\n        `[${serverAlias}].byServicePath[${servicePath}]`\n      )\n      if (Model) {\n        var model = new Model(current, { clone: true })\n      } else {\n        var copyData = mergeWithAccessors({}, current)\n      }\n      let item = model || copyData\n      if (keepCopiesInStore) {\n        state.copiesById[id] = item\n      } else {\n        // Since it won't be added to the store, make it a Vue object\n        if (!item.hasOwnProperty('__ob__')) {\n          item = Vue.observable(item)\n        }\n        Model.copiesById[id] = item\n      }\n    },\n    // Resets the copy to match the original record, locally\n    resetCopy(state, id) {\n      const { servicePath, keepCopiesInStore } = state\n      const Model = _get(\n        models,\n        `[${state.serverAlias}].byServicePath[${servicePath}]`\n      )\n      const copy = keepCopiesInStore\n        ? state.copiesById[id]\n        : Model && _get(Model, `copiesById[${id}]`)\n      if (copy) {\n        const original =\n          copy[state.idField] != null\n            ? state.keyedById[id]\n            : state.tempsById[id]\n        mergeWithAccessors(copy, original)\n      }\n    },\n    // Deep assigns copy to original record, locally\n    commitCopy(state, id) {\n      const { servicePath, keepCopiesInStore } = state\n      const Model = _get(\n        models,\n        `[${state.serverAlias}].byServicePath[${servicePath}]`\n      )\n      const copy = keepCopiesInStore\n        ? state.copiesById[id]\n        : Model && _get(Model, `copiesById[${id}]`)\n      if (copy) {\n        const original =\n          copy[state.idField] != null\n            ? state.keyedById[id]\n            : state.tempsById[id]\n        mergeWithAccessors(original, copy)\n      }\n    },\n    // Removes the copy from copiesById\n    clearCopy(state, id) {\n      const newCopiesById = Object.assign({}, state.copiesById)\n      delete newCopiesById[id]\n      state.copiesById = newCopiesById\n    },\n    /**\n     * Stores pagination data on state.pagination based on the query identifier\n     * (qid) The qid must be manually assigned to `params.qid`\n     */\n    updatePaginationForQuery(state, { qid, response, query = {} }) {\n      const { data, total } = response\n      const { idField } = state\n      const ids = data.map(i => i[idField])\n      const queriedAt = new Date().getTime()\n      const { queryId, queryParams, pageId, pageParams } = getQueryInfo(\n        { qid, query },\n        response\n      )\n      if (!state.pagination[qid]) {\n        Vue.set(state.pagination, qid, {})\n      }\n      if (!query.hasOwnProperty('$limit') && response.hasOwnProperty('limit')) {\n        Vue.set(state.pagination, 'defaultLimit', response.limit)\n      }\n      if (!query.hasOwnProperty('$skip') && response.hasOwnProperty('skip')) {\n        Vue.set(state.pagination, 'defaultSkip', response.skip)\n      }\n      const mostRecent = {\n        query,\n        queryId,\n        queryParams,\n        pageId,\n        pageParams,\n        queriedAt,\n        total\n      }\n      const qidData = state.pagination[qid] || {}\n      Object.assign(qidData, { mostRecent })\n      qidData[queryId] = qidData[queryId] || {}\n      const queryData = {\n        total,\n        queryParams\n      }\n      Object.assign(qidData[queryId], queryData)\n      const pageData = {\n        [pageId]: { pageParams, ids, queriedAt }\n      }\n      Object.assign(qidData[queryId], pageData)\n      const newState = Object.assign({}, state.pagination[qid], qidData)\n      Vue.set(state.pagination, qid, newState)\n    },\n    setPending(state, method) {\n      const uppercaseMethod = method.charAt(0).toUpperCase() + method.slice(1)\n      state[`is${uppercaseMethod}Pending`] = true\n    },\n    unsetPending(state, method) {\n      const uppercaseMethod = method.charAt(0).toUpperCase() + method.slice(1)\n      state[`is${uppercaseMethod}Pending`] = false\n    },\n    setError(state, payload) {\n      const { method, error } = payload\n      const uppercaseMethod = method.charAt(0).toUpperCase() + method.slice(1)\n      state[`errorOn${uppercaseMethod}`] = Object.assign(\n        {},\n        serializeError(error)\n      )\n    },\n    clearError(state, method) {\n      const uppercaseMethod = method.charAt(0).toUpperCase() + method.slice(1)\n      state[`errorOn${uppercaseMethod}`] = null\n    }\n  }\n}\n"]}]}