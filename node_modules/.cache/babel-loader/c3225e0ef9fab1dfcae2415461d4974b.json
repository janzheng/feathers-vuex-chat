{"remainingRequest":"/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/babel-loader/lib/index.js!/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/feathers-vuex/dist/service-module/service-module.actions.js","dependencies":[{"path":"/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/feathers-vuex/dist/service-module/service-module.actions.js","mtime":1576553531990},{"path":"/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/cache-loader/dist/cjs.js","mtime":1576617922850},{"path":"/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/babel-loader/lib/index.js","mtime":1572970632149}],"contextDependencies":[],"result":["import \"core-js/modules/es6.object.keys\";\nimport \"core-js/modules/web.dom.iterable\";\nimport _objectDestructuringEmpty from \"/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/@babel/runtime-corejs2/helpers/esm/objectDestructuringEmpty\";\nimport _slicedToArray from \"/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport \"regenerator-runtime/runtime\";\nimport \"core-js/modules/es6.array.find\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator['throw'](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n/*\neslint\n@typescript-eslint/explicit-function-return-type: 0,\n@typescript-eslint/no-explicit-any: 0\n*/\n\n\nimport fastCopy from 'fast-copy';\nimport { getId } from \"../utils\";\nexport default function makeServiceActions(service) {\n  var serviceActions = {\n    find: function find(_ref, params) {\n      var commit = _ref.commit,\n          dispatch = _ref.dispatch;\n      params = params || {};\n      params = fastCopy(params);\n      commit('setPending', 'find');\n      return service.find(params).then(function (response) {\n        return dispatch('handleFindResponse', {\n          params: params,\n          response: response\n        });\n      }).catch(function (error) {\n        return dispatch('handleFindError', {\n          params: params,\n          error: error\n        });\n      });\n    },\n    // Two query syntaxes are supported, since actions only receive one argument.\n    //   1. Just pass the id: `get(1)`\n    //   2. Pass arguments as an array: `get([null, params])`\n    get: function get(_ref2, args) {\n      var state = _ref2.state,\n          getters = _ref2.getters,\n          commit = _ref2.commit,\n          dispatch = _ref2.dispatch;\n      var id;\n      var params;\n      var skipRequestIfExists;\n\n      if (Array.isArray(args)) {\n        id = args[0];\n        params = args[1] || {};\n      } else {\n        id = args;\n        params = {};\n      }\n\n      params = fastCopy(params);\n\n      if ('skipRequestIfExists' in params) {\n        skipRequestIfExists = params.skipRequestIfExists;\n        delete params.skipRequestIfExists;\n      } else {\n        skipRequestIfExists = state.skipRequestIfExists;\n      }\n\n      function getFromRemote() {\n        commit('setPending', 'get');\n        return service.get(id, params).then(function (item) {\n          return __awaiter(this, void 0, void 0,\n          /*#__PURE__*/\n          regeneratorRuntime.mark(function _callee() {\n            return regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) {\n                switch (_context.prev = _context.next) {\n                  case 0:\n                    _context.next = 2;\n                    return dispatch('addOrUpdate', item);\n\n                  case 2:\n                    commit('unsetPending', 'get');\n                    return _context.abrupt(\"return\", state.keyedById[id]);\n\n                  case 4:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }\n            }, _callee);\n          }));\n        }).catch(function (error) {\n          commit('setError', {\n            method: 'get',\n            error: error\n          });\n          commit('unsetPending', 'get');\n          return Promise.reject(error);\n        });\n      } // If the records is already in store, return it\n\n\n      var existingItem = getters.get(id, params);\n\n      if (existingItem && skipRequestIfExists) {\n        return Promise.resolve(existingItem);\n      }\n\n      return getFromRemote();\n    },\n    create: function create(_ref3, dataOrArray) {\n      var _this = this;\n\n      var commit = _ref3.commit,\n          dispatch = _ref3.dispatch,\n          state = _ref3.state;\n      var idField = state.idField,\n          tempIdField = state.tempIdField;\n      var data;\n      var params;\n      var tempIds;\n\n      if (Array.isArray(dataOrArray)) {\n        data = dataOrArray[0];\n        params = dataOrArray[1];\n      } else {\n        data = dataOrArray;\n      }\n\n      params = fastCopy(params);\n\n      if (Array.isArray(data)) {\n        tempIds = data.map(function (i) {\n          return i[tempIdField];\n        });\n      } else {\n        tempIds = [data[tempIdField]]; // Array of tempIds\n      }\n\n      params = params || {};\n      commit('setPending', 'create');\n      return service.create(data, params).then(function (response) {\n        return __awaiter(_this, void 0, void 0,\n        /*#__PURE__*/\n        regeneratorRuntime.mark(function _callee2() {\n          var id, tempId;\n          return regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  if (!Array.isArray(response)) {\n                    _context2.next = 6;\n                    break;\n                  }\n\n                  _context2.next = 3;\n                  return dispatch('addOrUpdateList', response);\n\n                case 3:\n                  response = response.map(function (item) {\n                    var id = getId(item, idField);\n                    return state.keyedById[id];\n                  });\n                  _context2.next = 12;\n                  break;\n\n                case 6:\n                  id = getId(response, idField);\n                  tempId = tempIds[0];\n\n                  if (id != null && tempId != null) {\n                    commit('updateTemp', {\n                      id: id,\n                      tempId: tempId\n                    });\n                  }\n\n                  _context2.next = 11;\n                  return dispatch('addOrUpdate', response);\n\n                case 11:\n                  response = _context2.sent;\n\n                case 12:\n                  commit('unsetPending', 'create');\n                  commit('removeTemps', tempIds);\n                  return _context2.abrupt(\"return\", response);\n\n                case 15:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2);\n        }));\n      }).catch(function (error) {\n        commit('setError', {\n          method: 'create',\n          error: error\n        });\n        commit('unsetPending', 'create');\n        return Promise.reject(error);\n      });\n    },\n    update: function update(_ref4, _ref5) {\n      var commit = _ref4.commit,\n          dispatch = _ref4.dispatch,\n          state = _ref4.state;\n\n      var _ref6 = _slicedToArray(_ref5, 3),\n          id = _ref6[0],\n          data = _ref6[1],\n          params = _ref6[2];\n\n      commit('setPending', 'update');\n      params = fastCopy(params);\n      return service.update(id, data, params).then(function (item) {\n        return __awaiter(this, void 0, void 0,\n        /*#__PURE__*/\n        regeneratorRuntime.mark(function _callee3() {\n          return regeneratorRuntime.wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  _context3.next = 2;\n                  return dispatch('addOrUpdate', item);\n\n                case 2:\n                  commit('unsetPending', 'update');\n                  return _context3.abrupt(\"return\", state.keyedById[id]);\n\n                case 4:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3);\n        }));\n      }).catch(function (error) {\n        commit('setError', {\n          method: 'update',\n          error: error\n        });\n        commit('unsetPending', 'update');\n        return Promise.reject(error);\n      });\n    },\n    patch: function patch(_ref7, _ref8) {\n      var commit = _ref7.commit,\n          dispatch = _ref7.dispatch,\n          state = _ref7.state;\n\n      var _ref9 = _slicedToArray(_ref8, 3),\n          id = _ref9[0],\n          data = _ref9[1],\n          params = _ref9[2];\n\n      commit('setPending', 'patch');\n      params = fastCopy(params);\n\n      if (service.FeathersVuexModel) {\n        data = service.FeathersVuexModel.diffOnPatch(data);\n      }\n\n      return service.patch(id, data, params).then(function (item) {\n        return __awaiter(this, void 0, void 0,\n        /*#__PURE__*/\n        regeneratorRuntime.mark(function _callee4() {\n          return regeneratorRuntime.wrap(function _callee4$(_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  _context4.next = 2;\n                  return dispatch('addOrUpdate', item);\n\n                case 2:\n                  commit('unsetPending', 'patch');\n                  return _context4.abrupt(\"return\", state.keyedById[id]);\n\n                case 4:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }\n          }, _callee4);\n        }));\n      }).catch(function (error) {\n        commit('setError', {\n          method: 'patch',\n          error: error\n        });\n        commit('unsetPending', 'patch');\n        return Promise.reject(error);\n      });\n    },\n    remove: function remove(_ref10, idOrArray) {\n      var commit = _ref10.commit;\n      var id;\n      var params;\n\n      if (Array.isArray(idOrArray)) {\n        id = idOrArray[0];\n        params = idOrArray[1];\n      } else {\n        id = idOrArray;\n      }\n\n      params = params || {};\n      params = fastCopy(params);\n      commit('setPending', 'remove');\n      return service.remove(id, params).then(function (item) {\n        commit('removeItem', id);\n        commit('unsetPending', 'remove');\n        return item;\n      }).catch(function (error) {\n        commit('setError', {\n          method: 'remove',\n          error: error\n        });\n        commit('unsetPending', 'remove');\n        return Promise.reject(error);\n      });\n    }\n  };\n  var actions = {\n    /**\n     * Handle the response from the find action.\n     *\n     * @param payload consists of the following two params\n     *   @param params - Remember that these params aren't what was sent to the\n     *         Feathers client.  The client modifies the params object.\n     *   @param response\n     */\n    handleFindResponse: function handleFindResponse(_ref11, _ref12) {\n      var state = _ref11.state,\n          commit = _ref11.commit,\n          dispatch = _ref11.dispatch;\n      var params = _ref12.params,\n          response = _ref12.response;\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee5() {\n        var _params$qid, qid, query, idField, mapItemFromState, data, mappedFromState;\n\n        return regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _params$qid = params.qid, qid = _params$qid === void 0 ? 'default' : _params$qid, query = params.query;\n                idField = state.idField;\n                _context5.next = 4;\n                return dispatch('addOrUpdateList', response);\n\n              case 4:\n                commit('unsetPending', 'find');\n\n                mapItemFromState = function mapItemFromState(item) {\n                  var id = getId(item, idField);\n                  return state.keyedById[id];\n                }; // The pagination data will be under `pagination.default` or whatever qid is passed.\n\n\n                response.data && commit('updatePaginationForQuery', {\n                  qid: qid,\n                  response: response,\n                  query: query\n                }); // Swap out the response records for their Vue-observable store versions\n\n                data = response.data || response;\n                mappedFromState = data.map(mapItemFromState);\n\n                if (mappedFromState[0] !== undefined) {\n                  response.data ? response.data = mappedFromState : response = mappedFromState;\n                }\n\n                _context5.next = 12;\n                return dispatch('afterFind', response);\n\n              case 12:\n                _context5.next = 14;\n                return _context5.sent;\n\n              case 14:\n                response = _context5.sent;\n                return _context5.abrupt(\"return\", response);\n\n              case 16:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }));\n    },\n    handleFindError: function handleFindError(_ref13, _ref14) {\n      var commit = _ref13.commit;\n      var params = _ref14.params,\n          error = _ref14.error;\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee6() {\n        return regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                commit('setError', {\n                  method: 'find',\n                  params: params,\n                  error: error\n                });\n                commit('unsetPending', 'find');\n                return _context6.abrupt(\"return\", Promise.reject(error));\n\n              case 3:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6);\n      }));\n    },\n    afterFind: function afterFind(_ref15, response) {\n      _objectDestructuringEmpty(_ref15);\n\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee7() {\n        return regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                return _context7.abrupt(\"return\", response);\n\n              case 1:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7);\n      }));\n    },\n    addOrUpdateList: function addOrUpdateList(_ref16, response) {\n      var state = _ref16.state,\n          commit = _ref16.commit;\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee8() {\n        var list, isPaginated, toAdd, toUpdate, toRemove, idField, autoRemove;\n        return regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                list = response.data || response;\n                isPaginated = response.hasOwnProperty('total');\n                toAdd = [];\n                toUpdate = [];\n                toRemove = [];\n                idField = state.idField, autoRemove = state.autoRemove;\n                list.forEach(function (item) {\n                  var id = getId(item, idField);\n                  var existingItem = state.keyedById[id];\n\n                  if (id !== null && id !== undefined) {\n                    existingItem ? toUpdate.push(item) : toAdd.push(item);\n                  }\n                });\n\n                if (!isPaginated && autoRemove) {\n                  // Find IDs from the state which are not in the list\n                  state.ids.forEach(function (id) {\n                    if (id !== state.currentId && !list.some(function (item) {\n                      return getId(item, idField) === id;\n                    })) {\n                      toRemove.push(state.keyedById[id]);\n                    }\n                  });\n                  commit('removeItems', toRemove); // commit removal\n                }\n\n                if (service.FeathersVuexModel) {\n                  toAdd.forEach(function (item, index) {\n                    toAdd[index] = new service.FeathersVuexModel(item, {\n                      skipCommit: true\n                    });\n                  });\n                }\n\n                commit('addItems', toAdd);\n                commit('updateItems', toUpdate);\n                return _context8.abrupt(\"return\", response);\n\n              case 12:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8);\n      }));\n    },\n\n    /**\n     * Adds or updates an item. If a matching temp record is found in the store,\n     * the temp record will completely replace the existingItem. This is to work\n     * around the common scenario where the realtime `created` event arrives before\n     * the `create` response returns to create the record. The reference to the\n     * original temporary record must be maintained in order to preserve reactivity.\n     */\n    addOrUpdate: function addOrUpdate(_ref17, item) {\n      var state = _ref17.state,\n          commit = _ref17.commit;\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee9() {\n        var idField, id, existingItem, isIdOk, temp;\n        return regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                idField = state.idField;\n                id = getId(item, idField);\n                existingItem = state.keyedById[id];\n                isIdOk = id !== null && id !== undefined;\n\n                if (service.FeathersVuexModel && !item.isFeathersVuexInstance) {\n                  item = new service.FeathersVuexModel(item);\n                } // If the item has a matching temp, update the temp and provide it as the new item.\n\n\n                temp = state.tempsByNewId[id];\n\n                if (temp) {\n                  commit('merge', {\n                    dest: temp,\n                    source: item\n                  });\n                  commit('remove__isTemp', temp);\n                }\n\n                if (isIdOk) {\n                  if (existingItem && temp) {\n                    commit('replaceItemWithTemp', {\n                      item: item,\n                      temp: temp\n                    });\n                  } else {\n                    existingItem ? commit('updateItem', temp || item) : commit('addItem', temp || item);\n                  }\n                }\n\n                return _context9.abrupt(\"return\", temp || item);\n\n              case 9:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9);\n      }));\n    }\n  };\n  /**\n   * Only add a method to the store if the service actually has that same method.\n   */\n\n  Object.keys(serviceActions).map(function (method) {\n    if (service[method] && typeof service[method] === 'function') {\n      actions[method] = serviceActions[method];\n    }\n  });\n  return actions;\n}",{"version":3,"sources":["/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/feathers-vuex/dist/service-module/service-module.actions.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","fastCopy","getId","makeServiceActions","service","serviceActions","find","params","commit","dispatch","response","catch","error","get","args","state","getters","id","skipRequestIfExists","Array","isArray","getFromRemote","item","keyedById","method","existingItem","create","dataOrArray","idField","tempIdField","data","tempIds","map","i","tempId","update","patch","FeathersVuexModel","diffOnPatch","remove","idOrArray","actions","handleFindResponse","qid","query","mapItemFromState","mappedFromState","undefined","handleFindError","afterFind","addOrUpdateList","list","isPaginated","hasOwnProperty","toAdd","toUpdate","toRemove","autoRemove","forEach","push","ids","currentId","some","index","skipCommit","addOrUpdate","isIdOk","isFeathersVuexInstance","temp","tempsByNewId","dest","source","Object","keys"],"mappings":"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","sourcesContent":["var __awaiter =\n  (this && this.__awaiter) ||\n  function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n      return value instanceof P\n        ? value\n        : new P(function(resolve) {\n            resolve(value)\n          })\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n      function fulfilled(value) {\n        try {\n          step(generator.next(value))\n        } catch (e) {\n          reject(e)\n        }\n      }\n      function rejected(value) {\n        try {\n          step(generator['throw'](value))\n        } catch (e) {\n          reject(e)\n        }\n      }\n      function step(result) {\n        result.done\n          ? resolve(result.value)\n          : adopt(result.value).then(fulfilled, rejected)\n      }\n      step((generator = generator.apply(thisArg, _arguments || [])).next())\n    })\n  }\n/*\neslint\n@typescript-eslint/explicit-function-return-type: 0,\n@typescript-eslint/no-explicit-any: 0\n*/\nimport fastCopy from 'fast-copy'\nimport { getId } from '../utils'\nexport default function makeServiceActions(service) {\n  const serviceActions = {\n    find({ commit, dispatch }, params) {\n      params = params || {}\n      params = fastCopy(params)\n      commit('setPending', 'find')\n      return service\n        .find(params)\n        .then(response => dispatch('handleFindResponse', { params, response }))\n        .catch(error => dispatch('handleFindError', { params, error }))\n    },\n    // Two query syntaxes are supported, since actions only receive one argument.\n    //   1. Just pass the id: `get(1)`\n    //   2. Pass arguments as an array: `get([null, params])`\n    get({ state, getters, commit, dispatch }, args) {\n      let id\n      let params\n      let skipRequestIfExists\n      if (Array.isArray(args)) {\n        id = args[0]\n        params = args[1] || {}\n      } else {\n        id = args\n        params = {}\n      }\n      params = fastCopy(params)\n      if ('skipRequestIfExists' in params) {\n        skipRequestIfExists = params.skipRequestIfExists\n        delete params.skipRequestIfExists\n      } else {\n        skipRequestIfExists = state.skipRequestIfExists\n      }\n      function getFromRemote() {\n        commit('setPending', 'get')\n        return service\n          .get(id, params)\n          .then(function(item) {\n            return __awaiter(this, void 0, void 0, function*() {\n              yield dispatch('addOrUpdate', item)\n              commit('unsetPending', 'get')\n              return state.keyedById[id]\n            })\n          })\n          .catch(error => {\n            commit('setError', { method: 'get', error })\n            commit('unsetPending', 'get')\n            return Promise.reject(error)\n          })\n      }\n      // If the records is already in store, return it\n      const existingItem = getters.get(id, params)\n      if (existingItem && skipRequestIfExists) {\n        return Promise.resolve(existingItem)\n      }\n      return getFromRemote()\n    },\n    create({ commit, dispatch, state }, dataOrArray) {\n      const { idField, tempIdField } = state\n      let data\n      let params\n      let tempIds\n      if (Array.isArray(dataOrArray)) {\n        data = dataOrArray[0]\n        params = dataOrArray[1]\n      } else {\n        data = dataOrArray\n      }\n      params = fastCopy(params)\n      if (Array.isArray(data)) {\n        tempIds = data.map(i => i[tempIdField])\n      } else {\n        tempIds = [data[tempIdField]] // Array of tempIds\n      }\n      params = params || {}\n      commit('setPending', 'create')\n      return service\n        .create(data, params)\n        .then(response =>\n          __awaiter(this, void 0, void 0, function*() {\n            if (Array.isArray(response)) {\n              yield dispatch('addOrUpdateList', response)\n              response = response.map(item => {\n                const id = getId(item, idField)\n                return state.keyedById[id]\n              })\n            } else {\n              const id = getId(response, idField)\n              const tempId = tempIds[0]\n              if (id != null && tempId != null) {\n                commit('updateTemp', { id, tempId })\n              }\n              response = yield dispatch('addOrUpdate', response)\n              // response = state.keyedById[id]\n            }\n            commit('unsetPending', 'create')\n            commit('removeTemps', tempIds)\n            return response\n          })\n        )\n        .catch(error => {\n          commit('setError', { method: 'create', error })\n          commit('unsetPending', 'create')\n          return Promise.reject(error)\n        })\n    },\n    update({ commit, dispatch, state }, [id, data, params]) {\n      commit('setPending', 'update')\n      params = fastCopy(params)\n      return service\n        .update(id, data, params)\n        .then(function(item) {\n          return __awaiter(this, void 0, void 0, function*() {\n            yield dispatch('addOrUpdate', item)\n            commit('unsetPending', 'update')\n            return state.keyedById[id]\n          })\n        })\n        .catch(error => {\n          commit('setError', { method: 'update', error })\n          commit('unsetPending', 'update')\n          return Promise.reject(error)\n        })\n    },\n    patch({ commit, dispatch, state }, [id, data, params]) {\n      commit('setPending', 'patch')\n      params = fastCopy(params)\n      if (service.FeathersVuexModel) {\n        data = service.FeathersVuexModel.diffOnPatch(data)\n      }\n      return service\n        .patch(id, data, params)\n        .then(function(item) {\n          return __awaiter(this, void 0, void 0, function*() {\n            yield dispatch('addOrUpdate', item)\n            commit('unsetPending', 'patch')\n            return state.keyedById[id]\n          })\n        })\n        .catch(error => {\n          commit('setError', { method: 'patch', error })\n          commit('unsetPending', 'patch')\n          return Promise.reject(error)\n        })\n    },\n    remove({ commit }, idOrArray) {\n      let id\n      let params\n      if (Array.isArray(idOrArray)) {\n        id = idOrArray[0]\n        params = idOrArray[1]\n      } else {\n        id = idOrArray\n      }\n      params = params || {}\n      params = fastCopy(params)\n      commit('setPending', 'remove')\n      return service\n        .remove(id, params)\n        .then(item => {\n          commit('removeItem', id)\n          commit('unsetPending', 'remove')\n          return item\n        })\n        .catch(error => {\n          commit('setError', { method: 'remove', error })\n          commit('unsetPending', 'remove')\n          return Promise.reject(error)\n        })\n    }\n  }\n  const actions = {\n    /**\n     * Handle the response from the find action.\n     *\n     * @param payload consists of the following two params\n     *   @param params - Remember that these params aren't what was sent to the\n     *         Feathers client.  The client modifies the params object.\n     *   @param response\n     */\n    handleFindResponse({ state, commit, dispatch }, { params, response }) {\n      return __awaiter(this, void 0, void 0, function*() {\n        const { qid = 'default', query } = params\n        const { idField } = state\n        yield dispatch('addOrUpdateList', response)\n        commit('unsetPending', 'find')\n        const mapItemFromState = item => {\n          const id = getId(item, idField)\n          return state.keyedById[id]\n        }\n        // The pagination data will be under `pagination.default` or whatever qid is passed.\n        response.data &&\n          commit('updatePaginationForQuery', { qid, response, query })\n        // Swap out the response records for their Vue-observable store versions\n        const data = response.data || response\n        const mappedFromState = data.map(mapItemFromState)\n        if (mappedFromState[0] !== undefined) {\n          response.data\n            ? (response.data = mappedFromState)\n            : (response = mappedFromState)\n        }\n        response = yield yield dispatch('afterFind', response)\n        return response\n      })\n    },\n    handleFindError({ commit }, { params, error }) {\n      return __awaiter(this, void 0, void 0, function*() {\n        commit('setError', { method: 'find', params, error })\n        commit('unsetPending', 'find')\n        return Promise.reject(error)\n      })\n    },\n    afterFind({}, response) {\n      return __awaiter(this, void 0, void 0, function*() {\n        return response\n      })\n    },\n    addOrUpdateList({ state, commit }, response) {\n      return __awaiter(this, void 0, void 0, function*() {\n        const list = response.data || response\n        const isPaginated = response.hasOwnProperty('total')\n        const toAdd = []\n        const toUpdate = []\n        const toRemove = []\n        const { idField, autoRemove } = state\n        list.forEach(item => {\n          let id = getId(item, idField)\n          let existingItem = state.keyedById[id]\n          if (id !== null && id !== undefined) {\n            existingItem ? toUpdate.push(item) : toAdd.push(item)\n          }\n        })\n        if (!isPaginated && autoRemove) {\n          // Find IDs from the state which are not in the list\n          state.ids.forEach(id => {\n            if (\n              id !== state.currentId &&\n              !list.some(item => getId(item, idField) === id)\n            ) {\n              toRemove.push(state.keyedById[id])\n            }\n          })\n          commit('removeItems', toRemove) // commit removal\n        }\n        if (service.FeathersVuexModel) {\n          toAdd.forEach((item, index) => {\n            toAdd[index] = new service.FeathersVuexModel(item, {\n              skipCommit: true\n            })\n          })\n        }\n        commit('addItems', toAdd)\n        commit('updateItems', toUpdate)\n        return response\n      })\n    },\n    /**\n     * Adds or updates an item. If a matching temp record is found in the store,\n     * the temp record will completely replace the existingItem. This is to work\n     * around the common scenario where the realtime `created` event arrives before\n     * the `create` response returns to create the record. The reference to the\n     * original temporary record must be maintained in order to preserve reactivity.\n     */\n    addOrUpdate({ state, commit }, item) {\n      return __awaiter(this, void 0, void 0, function*() {\n        const { idField } = state\n        let id = getId(item, idField)\n        let existingItem = state.keyedById[id]\n        const isIdOk = id !== null && id !== undefined\n        if (service.FeathersVuexModel && !item.isFeathersVuexInstance) {\n          item = new service.FeathersVuexModel(item)\n        }\n        // If the item has a matching temp, update the temp and provide it as the new item.\n        const temp = state.tempsByNewId[id]\n        if (temp) {\n          commit('merge', { dest: temp, source: item })\n          commit('remove__isTemp', temp)\n        }\n        if (isIdOk) {\n          if (existingItem && temp) {\n            commit('replaceItemWithTemp', { item, temp })\n          } else {\n            existingItem\n              ? commit('updateItem', temp || item)\n              : commit('addItem', temp || item)\n          }\n        }\n        return temp || item\n      })\n    }\n  }\n  /**\n   * Only add a method to the store if the service actually has that same method.\n   */\n  Object.keys(serviceActions).map(method => {\n    if (service[method] && typeof service[method] === 'function') {\n      actions[method] = serviceActions[method]\n    }\n  })\n  return actions\n}\n"]}]}