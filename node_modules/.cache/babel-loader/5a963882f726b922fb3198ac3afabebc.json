{"remainingRequest":"/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/babel-loader/lib/index.js!/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/feathers-vuex/dist/FeathersVuexFormWrapper.js","dependencies":[{"path":"/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/feathers-vuex/dist/FeathersVuexFormWrapper.js","mtime":1576553531990},{"path":"/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/cache-loader/dist/cjs.js","mtime":1576617922850},{"path":"/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/babel-loader/lib/index.js","mtime":1572970632149}],"contextDependencies":[],"result":["import \"regenerator-runtime/runtime\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator['throw'](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nexport default {\n  name: 'FeathersVuexFormWrapper',\n  model: {\n    prop: 'item',\n    event: 'update:item'\n  },\n  props: {\n    item: {\n      type: Object,\n      required: true\n    },\n\n    /**\n     * By default, when you call the `save` method, the cloned data will be\n     * committed to the store BEFORE saving tot he API server. Set\n     * `:eager=\"false\"` to only update the store with the API server response.\n     */\n    eager: {\n      type: Boolean,\n      default: true\n    },\n    // Set to false to prevent re-cloning if the object updates.\n    watch: {\n      type: Boolean,\n      default: true\n    }\n  },\n  data: function data() {\n    return {\n      clone: null,\n      isDirty: false\n    };\n  },\n  computed: {\n    isNew: function isNew() {\n      return this.item && this.item.__isTemp || false;\n    }\n  },\n  watch: {\n    item: {\n      handler: 'setup',\n      immediate: true,\n      deep: true\n    }\n  },\n  methods: {\n    setup: function setup() {\n      if (this.item) {\n        this.isDirty = false; // Unwatch the clone to prevent running watchers during reclone\n\n        if (this.unwatchClone) {\n          this.unwatchClone();\n        }\n\n        this.clone = this.item.clone(); // Watch the new clone.\n\n        this.unwatchClone = this.$watch('clone', {\n          handler: 'markAsDirty',\n          deep: true\n        });\n      }\n    },\n    save: function save(params) {\n      var _this = this;\n\n      if (this.eager) {\n        this.clone.commit();\n      }\n\n      return this.clone.save(params).then(function (response) {\n        _this.$emit('saved', response);\n\n        if (_this.isNew) {\n          _this.$emit('saved-new', response);\n        }\n\n        return response;\n      });\n    },\n    reset: function reset() {\n      this.clone.reset();\n      this.$emit('reset', this.item);\n    },\n    remove: function remove() {\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee() {\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.item.remove();\n\n              case 2:\n                this.$emit('removed', this.item);\n                return _context.abrupt(\"return\", this.item);\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    },\n    markAsDirty: function markAsDirty() {\n      if (!this.isDirty) {\n        this.isDirty = true;\n      }\n    }\n  },\n  render: function render() {\n    var clone = this.clone,\n        save = this.save,\n        reset = this.reset,\n        remove = this.remove,\n        isDirty = this.isDirty,\n        isNew = this.isNew;\n    return this.$scopedSlots.default({\n      clone: clone,\n      save: save,\n      reset: reset,\n      remove: remove,\n      isDirty: isDirty,\n      isNew: isNew\n    });\n  }\n};",{"version":3,"sources":["/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/feathers-vuex/dist/FeathersVuexFormWrapper.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","name","model","prop","event","props","item","type","Object","required","eager","Boolean","default","watch","data","clone","isDirty","computed","isNew","__isTemp","handler","immediate","deep","methods","setup","unwatchClone","$watch","save","params","commit","response","$emit","reset","remove","markAsDirty","render","$scopedSlots"],"mappings":"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","sourcesContent":["var __awaiter =\n  (this && this.__awaiter) ||\n  function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n      return value instanceof P\n        ? value\n        : new P(function(resolve) {\n            resolve(value)\n          })\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n      function fulfilled(value) {\n        try {\n          step(generator.next(value))\n        } catch (e) {\n          reject(e)\n        }\n      }\n      function rejected(value) {\n        try {\n          step(generator['throw'](value))\n        } catch (e) {\n          reject(e)\n        }\n      }\n      function step(result) {\n        result.done\n          ? resolve(result.value)\n          : adopt(result.value).then(fulfilled, rejected)\n      }\n      step((generator = generator.apply(thisArg, _arguments || [])).next())\n    })\n  }\nexport default {\n  name: 'FeathersVuexFormWrapper',\n  model: {\n    prop: 'item',\n    event: 'update:item'\n  },\n  props: {\n    item: {\n      type: Object,\n      required: true\n    },\n    /**\n     * By default, when you call the `save` method, the cloned data will be\n     * committed to the store BEFORE saving tot he API server. Set\n     * `:eager=\"false\"` to only update the store with the API server response.\n     */\n    eager: {\n      type: Boolean,\n      default: true\n    },\n    // Set to false to prevent re-cloning if the object updates.\n    watch: {\n      type: Boolean,\n      default: true\n    }\n  },\n  data: () => ({\n    clone: null,\n    isDirty: false\n  }),\n  computed: {\n    isNew() {\n      return (this.item && this.item.__isTemp) || false\n    }\n  },\n  watch: {\n    item: {\n      handler: 'setup',\n      immediate: true,\n      deep: true\n    }\n  },\n  methods: {\n    setup() {\n      if (this.item) {\n        this.isDirty = false\n        // Unwatch the clone to prevent running watchers during reclone\n        if (this.unwatchClone) {\n          this.unwatchClone()\n        }\n        this.clone = this.item.clone()\n        // Watch the new clone.\n        this.unwatchClone = this.$watch('clone', {\n          handler: 'markAsDirty',\n          deep: true\n        })\n      }\n    },\n    save(params) {\n      if (this.eager) {\n        this.clone.commit()\n      }\n      return this.clone.save(params).then(response => {\n        this.$emit('saved', response)\n        if (this.isNew) {\n          this.$emit('saved-new', response)\n        }\n        return response\n      })\n    },\n    reset() {\n      this.clone.reset()\n      this.$emit('reset', this.item)\n    },\n    remove() {\n      return __awaiter(this, void 0, void 0, function*() {\n        yield this.item.remove()\n        this.$emit('removed', this.item)\n        return this.item\n      })\n    },\n    markAsDirty() {\n      if (!this.isDirty) {\n        this.isDirty = true\n      }\n    }\n  },\n  render() {\n    const { clone, save, reset, remove, isDirty, isNew } = this\n    return this.$scopedSlots.default({\n      clone,\n      save,\n      reset,\n      remove,\n      isDirty,\n      isNew\n    })\n  }\n}\n"]}]}