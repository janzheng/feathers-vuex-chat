{"remainingRequest":"/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/babel-loader/lib/index.js!/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/feathers-vuex/dist/service-module/make-model.js","dependencies":[{"path":"/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/feathers-vuex/dist/service-module/make-model.js","mtime":1576553531990},{"path":"/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/cache-loader/dist/cjs.js","mtime":1576617922850},{"path":"/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/babel-loader/lib/index.js","mtime":1572970632149}],"contextDependencies":[],"result":["import _classCallCheck from \"/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/@babel/runtime-corejs2/helpers/esm/createClass\";\nimport { globalModels, prepareAddModel } from \"./global-models\";\nimport { mergeWithAccessors, checkNamespace, getId as _getId } from \"../utils\";\nimport _merge from 'lodash/merge';\nimport _get from 'lodash/get';\nimport EventEmitter from 'events';\nvar defaultOptions = {\n  clone: false,\n  commit: true,\n  merge: true\n};\n/**\n *\n * @param options\n */\n\nexport default function makeModel(options) {\n  var addModel = prepareAddModel(options);\n  var serverAlias = options.serverAlias; // If this serverAlias already has a BaseModel, nreturn it\n\n  var ExistingBaseModel = _get(globalModels, \"[\".concat(serverAlias, \"].BaseModel\"));\n\n  if (ExistingBaseModel) {\n    return ExistingBaseModel;\n  }\n\n  var BaseModel =\n  /*#__PURE__*/\n  function () {\n    function BaseModel(data, options) {\n      _classCallCheck(this, BaseModel);\n\n      // You have to pass at least an empty object to get a tempId.\n      var originalData = data;\n      data = data || {};\n      options = Object.assign({}, defaultOptions, options);\n      var _this$constructor = this.constructor,\n          store = _this$constructor.store,\n          keepCopiesInStore = _this$constructor.keepCopiesInStore,\n          copiesByIdOnModel = _this$constructor.copiesById,\n          models = _this$constructor.models,\n          instanceDefaults = _this$constructor.instanceDefaults,\n          idField = _this$constructor.idField,\n          tempIdField = _this$constructor.tempIdField,\n          setupInstance = _this$constructor.setupInstance,\n          getFromStore = _this$constructor.getFromStore,\n          namespace = _this$constructor.namespace,\n          _commit = _this$constructor._commit;\n\n      var id = _getId(data, idField);\n\n      var hasValidId = id !== null && id !== undefined;\n      var tempId = data && data.hasOwnProperty(tempIdField) ? data[tempIdField] : undefined;\n      var hasValidTempId = tempId !== null && tempId !== undefined;\n      var copiesById = keepCopiesInStore ? store.state[namespace].copiesById : copiesByIdOnModel;\n      var existingItem = hasValidId && !options.clone ? getFromStore.call(this.constructor, id) : null; // If it already exists, update the original and return\n\n      if (existingItem) {\n        data = setupInstance.call(this, data, {\n          models: models,\n          store: store\n        }) || data;\n\n        _commit.call(this.constructor, 'mergeInstance', data);\n\n        return existingItem;\n      } // If cloning and a clone already exists, update and return the original clone. Only one clone is allowed.\n\n\n      var existingClone = (hasValidId || hasValidTempId) && options.clone ? copiesById[id] || copiesById[tempId] : null;\n\n      if (existingClone) {\n        // This must be done in a mutation to avoid Vuex errors.\n        _commit.call(this.constructor, 'merge', {\n          dest: existingClone,\n          source: data\n        });\n\n        return existingClone;\n      } // Mark as a clone\n\n\n      if (options.clone) {\n        Object.defineProperty(this, '__isClone', {\n          value: true,\n          enumerable: false\n        });\n      } // Setup instanceDefaults\n\n\n      if (instanceDefaults && typeof instanceDefaults === 'function') {\n        var defaults = instanceDefaults.call(this, data, {\n          models: models,\n          store: store\n        }) || data;\n        mergeWithAccessors(this, defaults);\n      } // Handles Vue objects or regular ones. We can't simply assign or return\n      // the data due to how Vue wraps everything into an accessor.\n\n\n      if (options.merge !== false) {\n        mergeWithAccessors(this, setupInstance.call(this, data, {\n          models: models,\n          store: store\n        }) || data);\n      } // Add the item to the store\n      // Make sure originalData wasn't an empty object.\n\n\n      if (!options.clone && options.commit !== false && store) {\n        _commit.call(this.constructor, 'addItem', this);\n      }\n\n      return this;\n    } // eslint-disable-next-line\n\n\n    _createClass(BaseModel, [{\n      key: \"clone\",\n\n      /**\n       * clone the current record using the `createCopy` mutation\n       */\n      value: function clone() {\n        var _this$constructor2 = this.constructor,\n            idField = _this$constructor2.idField,\n            tempIdField = _this$constructor2.tempIdField;\n\n        if (this.__isClone) {\n          throw new Error('You cannot clone a copy');\n        }\n\n        var id = _getId(this, idField) != null ? _getId(this, idField) : this[tempIdField];\n        return this._clone(id);\n      }\n    }, {\n      key: \"_clone\",\n      value: function _clone(id) {\n        var _this$constructor3 = this.constructor,\n            store = _this$constructor3.store,\n            copiesById = _this$constructor3.copiesById,\n            namespace = _this$constructor3.namespace,\n            _commit = _this$constructor3._commit,\n            _getters = _this$constructor3._getters;\n        var keepCopiesInStore = store.state[namespace].keepCopiesInStore;\n\n        _commit.call(this.constructor, \"createCopy\", id);\n\n        if (keepCopiesInStore) {\n          return _getters.call(this.constructor, 'getCopyById', id);\n        } else {\n          return copiesById[id];\n        }\n      }\n      /**\n       * Reset a clone to match the instance in the store.\n       */\n\n    }, {\n      key: \"reset\",\n      value: function reset() {\n        var _this$constructor4 = this.constructor,\n            idField = _this$constructor4.idField,\n            tempIdField = _this$constructor4.tempIdField,\n            _commit = _this$constructor4._commit;\n\n        if (this.__isClone) {\n          var id = _getId(this, idField) != null ? _getId(this, idField) : this[tempIdField];\n\n          _commit.call(this.constructor, 'resetCopy', id);\n\n          return this;\n        } else {\n          throw new Error('You cannot reset a non-copy');\n        }\n      }\n      /**\n       * Update a store instance to match a clone.\n       */\n\n    }, {\n      key: \"commit\",\n      value: function commit() {\n        var _this$constructor5 = this.constructor,\n            idField = _this$constructor5.idField,\n            tempIdField = _this$constructor5.tempIdField,\n            _commit = _this$constructor5._commit,\n            _getters = _this$constructor5._getters;\n\n        if (this.__isClone) {\n          var id = _getId(this, idField) != null ? _getId(this, idField) : this[tempIdField];\n\n          _commit.call(this.constructor, 'commitCopy', id);\n\n          return _getters.call(this.constructor, 'get', id);\n        } else {\n          throw new Error('You cannot call commit on a non-copy');\n        }\n      }\n      /**\n       * A shortcut to either call create or patch/update\n       * @param params\n       */\n\n    }, {\n      key: \"save\",\n      value: function save(params) {\n        var _this$constructor6 = this.constructor,\n            idField = _this$constructor6.idField,\n            preferUpdate = _this$constructor6.preferUpdate;\n\n        var id = _getId(this, idField);\n\n        if (id != null) {\n          return preferUpdate ? this.update(params) : this.patch(params);\n        } else {\n          return this.create(params);\n        }\n      }\n      /**\n       * Calls service create with the current instance data\n       * @param params\n       */\n\n    }, {\n      key: \"create\",\n      value: function create(params) {\n        var _dispatch = this.constructor._dispatch;\n        var data = Object.assign({}, this);\n\n        if (data[options.idField] === null) {\n          delete data[options.idField];\n        }\n\n        return _dispatch.call(this.constructor, 'create', [data, params]);\n      }\n      /**\n       * Calls service patch with the current instance data\n       * @param params\n       */\n\n    }, {\n      key: \"patch\",\n      value: function patch(params) {\n        var _this$constructor7 = this.constructor,\n            idField = _this$constructor7.idField,\n            _dispatch = _this$constructor7._dispatch;\n\n        var id = _getId(this, idField);\n\n        if (id == null) {\n          var error = new Error(\"Missing \".concat(idField, \" property. You must create the data before you can patch with this data\"));\n          return Promise.reject(error);\n        }\n\n        return _dispatch.call(this.constructor, 'patch', [id, this, params]);\n      }\n      /**\n       * Calls service update with the current instance data\n       * @param params\n       */\n\n    }, {\n      key: \"update\",\n      value: function update(params) {\n        var _this$constructor8 = this.constructor,\n            idField = _this$constructor8.idField,\n            _dispatch = _this$constructor8._dispatch;\n\n        var id = _getId(this, idField);\n\n        if (!id) {\n          var error = new Error(\"Missing \".concat(idField, \" property. You must create the data before you can update with this data\"));\n          return Promise.reject(error);\n        }\n\n        return _dispatch.call(this.constructor, 'update', [id, this, params]);\n      }\n      /**\n       * Calls service remove with the current instance id\n       * @param params\n       */\n\n    }, {\n      key: \"remove\",\n      value: function remove(params) {\n        var _this$constructor9 = this.constructor,\n            idField = _this$constructor9.idField,\n            tempIdField = _this$constructor9.tempIdField,\n            _dispatch = _this$constructor9._dispatch,\n            _commit = _this$constructor9._commit;\n\n        var id = _getId(this, idField);\n\n        if (id != null) {\n          if (params && params.eager) {\n            _commit.call(this.constructor, 'removeItem', id);\n          }\n\n          return _dispatch.call(this.constructor, 'remove', [id, params]);\n        } else {\n          _commit.call(this.constructor, 'removeTemps', [this[tempIdField]]);\n\n          return Promise.resolve(this);\n        }\n      }\n    }, {\n      key: \"toJSON\",\n      value: function toJSON() {\n        return _merge({}, this);\n      }\n    }], [{\n      key: \"instanceDefaults\",\n      value: function instanceDefaults(data, _ref) {\n        var models = _ref.models,\n            store = _ref.store;\n        return data;\n      } // eslint-disable-next-line\n\n    }, {\n      key: \"setupInstance\",\n      value: function setupInstance(data, _ref2) {\n        var models = _ref2.models,\n            store = _ref2.store;\n        return data;\n      }\n    }, {\n      key: \"diffOnPatch\",\n      value: function diffOnPatch(data) {\n        return data;\n      }\n    }, {\n      key: \"getId\",\n      value: function getId(record) {\n        var idField = this.constructor.idField;\n        return _getId(record, idField);\n      }\n    }, {\n      key: \"find\",\n      value: function find(params) {\n        return this._dispatch('find', params);\n      }\n    }, {\n      key: \"findInStore\",\n      value: function findInStore(params) {\n        return this._getters('find', params);\n      }\n    }, {\n      key: \"get\",\n      value: function get(id, params) {\n        if (params) {\n          return this._dispatch('get', [id, params]);\n        } else {\n          return this._dispatch('get', id);\n        }\n      }\n    }, {\n      key: \"getFromStore\",\n      value: function getFromStore(id, params) {\n        if (params) {\n          return this._getters('get', [id, params]);\n        } else {\n          return this._getters('get', id);\n        }\n      }\n      /**\n       * An alias for store.getters\n       * @param method the vuex getter name without the namespace\n       * @param payload if provided, the getter will be called as a function\n       */\n\n    }, {\n      key: \"_getters\",\n      value: function _getters(name, payload) {\n        var namespace = this.namespace,\n            store = this.store;\n\n        if (checkNamespace(namespace, this, options.debug)) {\n          if (!store.getters.hasOwnProperty(\"\".concat(namespace, \"/\").concat(name))) {\n            throw new Error(\"Could not find getter named \".concat(namespace, \"/\").concat(name));\n          }\n\n          if (payload !== undefined) {\n            return store.getters[\"\".concat(namespace, \"/\").concat(name)](payload);\n          } else {\n            return store.getters[\"\".concat(namespace, \"/\").concat(name)];\n          }\n        }\n      }\n      /**\n       * An alias for store.commit\n       * @param method the vuex mutation name without the namespace\n       * @param payload the payload for the mutation\n       */\n\n    }, {\n      key: \"_commit\",\n      value: function _commit(method, payload) {\n        var namespace = this.namespace,\n            store = this.store;\n\n        if (checkNamespace(namespace, this, options.debug)) {\n          store.commit(\"\".concat(namespace, \"/\").concat(method), payload);\n        }\n      }\n      /**\n       * An alias for store.dispatch\n       * @param method the vuex action name without the namespace\n       * @param payload the payload for the action\n       */\n\n    }, {\n      key: \"_dispatch\",\n      value: function _dispatch(method, payload) {\n        var namespace = this.namespace,\n            store = this.store;\n\n        if (checkNamespace(namespace, this, options.debug)) {\n          return store.dispatch(\"\".concat(namespace, \"/\").concat(method), payload);\n        }\n      }\n    }]);\n\n    return BaseModel;\n  }();\n\n  BaseModel.keepCopiesInStore = options.keepCopiesInStore;\n  BaseModel.idField = options.idField;\n  BaseModel.tempIdField = options.tempIdField;\n  BaseModel.preferUpdate = options.preferUpdate;\n  BaseModel.serverAlias = options.serverAlias;\n  BaseModel.models = globalModels; // Can access other Models here\n\n  BaseModel.copiesById = {};\n  BaseModel.merge = mergeWithAccessors;\n  BaseModel.modelName = 'BaseModel';\n\n  for (var n in EventEmitter.prototype) {\n    BaseModel[n] = EventEmitter.prototype[n];\n  }\n\n  addModel(BaseModel);\n  return BaseModel;\n}",{"version":3,"sources":["/Users/janzheng/Desktop/projects/_lessons/feathersjs/feathers-chat-vuex/node_modules/feathers-vuex/dist/service-module/make-model.js"],"names":["globalModels","prepareAddModel","mergeWithAccessors","checkNamespace","getId","_merge","_get","EventEmitter","defaultOptions","clone","commit","merge","makeModel","options","addModel","serverAlias","ExistingBaseModel","BaseModel","data","originalData","Object","assign","constructor","store","keepCopiesInStore","copiesByIdOnModel","copiesById","models","instanceDefaults","idField","tempIdField","setupInstance","getFromStore","namespace","_commit","id","hasValidId","undefined","tempId","hasOwnProperty","hasValidTempId","state","existingItem","call","existingClone","dest","source","defineProperty","value","enumerable","defaults","__isClone","Error","_clone","_getters","params","preferUpdate","update","patch","create","_dispatch","error","Promise","reject","eager","resolve","record","name","payload","debug","getters","method","dispatch","modelName","n","prototype"],"mappings":"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","sourcesContent":["import { globalModels, prepareAddModel } from './global-models'\nimport { mergeWithAccessors, checkNamespace, getId } from '../utils'\nimport _merge from 'lodash/merge'\nimport _get from 'lodash/get'\nimport EventEmitter from 'events'\nconst defaultOptions = {\n  clone: false,\n  commit: true,\n  merge: true\n}\n/**\n *\n * @param options\n */\nexport default function makeModel(options) {\n  const addModel = prepareAddModel(options)\n  const { serverAlias } = options\n  // If this serverAlias already has a BaseModel, nreturn it\n  const ExistingBaseModel = _get(globalModels, `[${serverAlias}].BaseModel`)\n  if (ExistingBaseModel) {\n    return ExistingBaseModel\n  }\n  class BaseModel {\n    constructor(data, options) {\n      // You have to pass at least an empty object to get a tempId.\n      const originalData = data\n      data = data || {}\n      options = Object.assign({}, defaultOptions, options)\n      const {\n        store,\n        keepCopiesInStore,\n        copiesById: copiesByIdOnModel,\n        models,\n        instanceDefaults,\n        idField,\n        tempIdField,\n        setupInstance,\n        getFromStore,\n        namespace,\n        _commit\n      } = this.constructor\n      const id = getId(data, idField)\n      const hasValidId = id !== null && id !== undefined\n      const tempId =\n        data && data.hasOwnProperty(tempIdField) ? data[tempIdField] : undefined\n      const hasValidTempId = tempId !== null && tempId !== undefined\n      const copiesById = keepCopiesInStore\n        ? store.state[namespace].copiesById\n        : copiesByIdOnModel\n      const existingItem =\n        hasValidId && !options.clone\n          ? getFromStore.call(this.constructor, id)\n          : null\n      // If it already exists, update the original and return\n      if (existingItem) {\n        data = setupInstance.call(this, data, { models, store }) || data\n        _commit.call(this.constructor, 'mergeInstance', data)\n        return existingItem\n      }\n      // If cloning and a clone already exists, update and return the original clone. Only one clone is allowed.\n      const existingClone =\n        (hasValidId || hasValidTempId) && options.clone\n          ? copiesById[id] || copiesById[tempId]\n          : null\n      if (existingClone) {\n        // This must be done in a mutation to avoid Vuex errors.\n        _commit.call(this.constructor, 'merge', {\n          dest: existingClone,\n          source: data\n        })\n        return existingClone\n      }\n      // Mark as a clone\n      if (options.clone) {\n        Object.defineProperty(this, '__isClone', {\n          value: true,\n          enumerable: false\n        })\n      }\n      // Setup instanceDefaults\n      if (instanceDefaults && typeof instanceDefaults === 'function') {\n        const defaults =\n          instanceDefaults.call(this, data, { models, store }) || data\n        mergeWithAccessors(this, defaults)\n      }\n      // Handles Vue objects or regular ones. We can't simply assign or return\n      // the data due to how Vue wraps everything into an accessor.\n      if (options.merge !== false) {\n        mergeWithAccessors(\n          this,\n          setupInstance.call(this, data, { models, store }) || data\n        )\n      }\n      // Add the item to the store\n      // Make sure originalData wasn't an empty object.\n      if (!options.clone && options.commit !== false && store) {\n        _commit.call(this.constructor, 'addItem', this)\n      }\n      return this\n    }\n    // eslint-disable-next-line\n    static instanceDefaults(data, { models, store }) {\n      return data\n    }\n    // eslint-disable-next-line\n    static setupInstance(data, { models, store }) {\n      return data\n    }\n    static diffOnPatch(data) {\n      return data\n    }\n    static getId(record) {\n      const { idField } = this.constructor\n      return getId(record, idField)\n    }\n    static find(params) {\n      return this._dispatch('find', params)\n    }\n    static findInStore(params) {\n      return this._getters('find', params)\n    }\n    static get(id, params) {\n      if (params) {\n        return this._dispatch('get', [id, params])\n      } else {\n        return this._dispatch('get', id)\n      }\n    }\n    static getFromStore(id, params) {\n      if (params) {\n        return this._getters('get', [id, params])\n      } else {\n        return this._getters('get', id)\n      }\n    }\n    /**\n     * An alias for store.getters\n     * @param method the vuex getter name without the namespace\n     * @param payload if provided, the getter will be called as a function\n     */\n    static _getters(name, payload) {\n      const { namespace, store } = this\n      if (checkNamespace(namespace, this, options.debug)) {\n        if (!store.getters.hasOwnProperty(`${namespace}/${name}`)) {\n          throw new Error(`Could not find getter named ${namespace}/${name}`)\n        }\n        if (payload !== undefined) {\n          return store.getters[`${namespace}/${name}`](payload)\n        } else {\n          return store.getters[`${namespace}/${name}`]\n        }\n      }\n    }\n    /**\n     * An alias for store.commit\n     * @param method the vuex mutation name without the namespace\n     * @param payload the payload for the mutation\n     */\n    static _commit(method, payload) {\n      const { namespace, store } = this\n      if (checkNamespace(namespace, this, options.debug)) {\n        store.commit(`${namespace}/${method}`, payload)\n      }\n    }\n    /**\n     * An alias for store.dispatch\n     * @param method the vuex action name without the namespace\n     * @param payload the payload for the action\n     */\n    static _dispatch(method, payload) {\n      const { namespace, store } = this\n      if (checkNamespace(namespace, this, options.debug)) {\n        return store.dispatch(`${namespace}/${method}`, payload)\n      }\n    }\n    /**\n     * clone the current record using the `createCopy` mutation\n     */\n    clone() {\n      const { idField, tempIdField } = this.constructor\n      if (this.__isClone) {\n        throw new Error('You cannot clone a copy')\n      }\n      const id =\n        getId(this, idField) != null ? getId(this, idField) : this[tempIdField]\n      return this._clone(id)\n    }\n    _clone(id) {\n      const {\n        store,\n        copiesById,\n        namespace,\n        _commit,\n        _getters\n      } = this.constructor\n      const { keepCopiesInStore } = store.state[namespace]\n      _commit.call(this.constructor, `createCopy`, id)\n      if (keepCopiesInStore) {\n        return _getters.call(this.constructor, 'getCopyById', id)\n      } else {\n        return copiesById[id]\n      }\n    }\n    /**\n     * Reset a clone to match the instance in the store.\n     */\n    reset() {\n      const { idField, tempIdField, _commit } = this.constructor\n      if (this.__isClone) {\n        const id =\n          getId(this, idField) != null\n            ? getId(this, idField)\n            : this[tempIdField]\n        _commit.call(this.constructor, 'resetCopy', id)\n        return this\n      } else {\n        throw new Error('You cannot reset a non-copy')\n      }\n    }\n    /**\n     * Update a store instance to match a clone.\n     */\n    commit() {\n      const { idField, tempIdField, _commit, _getters } = this.constructor\n      if (this.__isClone) {\n        const id =\n          getId(this, idField) != null\n            ? getId(this, idField)\n            : this[tempIdField]\n        _commit.call(this.constructor, 'commitCopy', id)\n        return _getters.call(this.constructor, 'get', id)\n      } else {\n        throw new Error('You cannot call commit on a non-copy')\n      }\n    }\n    /**\n     * A shortcut to either call create or patch/update\n     * @param params\n     */\n    save(params) {\n      const { idField, preferUpdate } = this.constructor\n      const id = getId(this, idField)\n      if (id != null) {\n        return preferUpdate ? this.update(params) : this.patch(params)\n      } else {\n        return this.create(params)\n      }\n    }\n    /**\n     * Calls service create with the current instance data\n     * @param params\n     */\n    create(params) {\n      const { _dispatch } = this.constructor\n      const data = Object.assign({}, this)\n      if (data[options.idField] === null) {\n        delete data[options.idField]\n      }\n      return _dispatch.call(this.constructor, 'create', [data, params])\n    }\n    /**\n     * Calls service patch with the current instance data\n     * @param params\n     */\n    patch(params) {\n      const { idField, _dispatch } = this.constructor\n      const id = getId(this, idField)\n      if (id == null) {\n        const error = new Error(\n          `Missing ${idField} property. You must create the data before you can patch with this data`\n        )\n        return Promise.reject(error)\n      }\n      return _dispatch.call(this.constructor, 'patch', [id, this, params])\n    }\n    /**\n     * Calls service update with the current instance data\n     * @param params\n     */\n    update(params) {\n      const { idField, _dispatch } = this.constructor\n      const id = getId(this, idField)\n      if (!id) {\n        const error = new Error(\n          `Missing ${idField} property. You must create the data before you can update with this data`\n        )\n        return Promise.reject(error)\n      }\n      return _dispatch.call(this.constructor, 'update', [id, this, params])\n    }\n    /**\n     * Calls service remove with the current instance id\n     * @param params\n     */\n    remove(params) {\n      const { idField, tempIdField, _dispatch, _commit } = this.constructor\n      const id = getId(this, idField)\n      if (id != null) {\n        if (params && params.eager) {\n          _commit.call(this.constructor, 'removeItem', id)\n        }\n        return _dispatch.call(this.constructor, 'remove', [id, params])\n      } else {\n        _commit.call(this.constructor, 'removeTemps', [this[tempIdField]])\n        return Promise.resolve(this)\n      }\n    }\n    toJSON() {\n      return _merge({}, this)\n    }\n  }\n  BaseModel.keepCopiesInStore = options.keepCopiesInStore\n  BaseModel.idField = options.idField\n  BaseModel.tempIdField = options.tempIdField\n  BaseModel.preferUpdate = options.preferUpdate\n  BaseModel.serverAlias = options.serverAlias\n  BaseModel.models = globalModels // Can access other Models here\n  BaseModel.copiesById = {}\n  BaseModel.merge = mergeWithAccessors\n  BaseModel.modelName = 'BaseModel'\n  for (var n in EventEmitter.prototype) {\n    BaseModel[n] = EventEmitter.prototype[n]\n  }\n  addModel(BaseModel)\n  return BaseModel\n}\n"]}]}