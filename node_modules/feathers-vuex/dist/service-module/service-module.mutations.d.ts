export default function makeServiceMutations(): {
    mergeInstance: (state: any, item: any) => void;
    merge: (state: any, { dest, source }: {
        dest: any;
        source: any;
    }) => void;
    addItem(state: any, item: any): void;
    addItems: (state: any, items: any) => void;
    updateItem(state: any, item: any): void;
    updateItems(state: any, items: any): void;
    updateTemp(state: any, { id, tempId }: {
        id: any;
        tempId: any;
    }): void;
    /**
     * Overwrites the item with matching id with the temp record.
     * This is to preserve reactivity for temp records.
     */
    replaceItemWithTemp(state: any, { item, temp }: {
        item: any;
        temp: any;
    }): void;
    remove__isTemp(state: any, temp: any): void;
    removeItem(state: any, item: any): void;
    removeTemps(state: any, tempIds: any): void;
    removeItems(state: any, items: any): void;
    clearAll(state: any): void;
    createCopy(state: any, id: any): void;
    resetCopy(state: any, id: any): void;
    commitCopy(state: any, id: any): void;
    clearCopy(state: any, id: any): void;
    /**
     * Stores pagination data on state.pagination based on the query identifier
     * (qid) The qid must be manually assigned to `params.qid`
     */
    updatePaginationForQuery(state: any, { qid, response, query }: {
        qid: any;
        response: any;
        query?: {};
    }): void;
    setPending(state: any, method: string): void;
    unsetPending(state: any, method: string): void;
    setError(state: any, payload: {
        method: string;
        error: Error;
    }): void;
    clearError(state: any, method: string): void;
};
